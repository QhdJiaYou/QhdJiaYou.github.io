<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  
  <title>
    
    Hexo
  </title>
  
    <link rel="shortcut icon" href="/favicon.ico">
    
  
<link rel="stylesheet" href="/css/style.css">

  
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<script src="/js/pace.min.js"></script>

<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <main class="content">
    <section class="jumbotron">
  <div class="video">
    
    <div class="video-frame">
      <img src="/images/ocean/overlay-hero.png" alt="Decorative image frame">
    </div>
    
    <div class="video-media">
      <video playsinline="" autoplay="" loop="" muted="" data-autoplay="" poster="/images/ocean/ocean.png"
        x5-video-player-type="h5">
        <source src="/images/ocean/ocean.mp4" type="video/mp4">
        <source src="/images/ocean/ocean.ogv" type="video/ogg">
        <source src="/images/ocean/ocean.webm" type="video/webm">
        <p>Your user agent does not support the HTML5 Video element.</p>
      </video>
      <div class="video-overlay"></div>
    </div>
    <div class="video-inner text-center text-white">
      <h1><a href="/">Hexo</a></h1>
      <p></p>
      <div><img src="/images/hexo-inverted.svg" class="brand" alt="Hexo"></div>
    </div>
    <div class="video-learn-more">
      <a class="anchor" href="#landingpage"><i class="fe fe-mouse"></i></a>
    </div>
  </div>
</section>
<div id="landingpage">
  <section class="outer">
  <article class="articles">
    
    <h1 class="page-type-title"></h1>
    
    
    <article id="post-计算机网络" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h2 itemprop="name">
  <a class="article-title" href="/2020/11/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络基础</a>
</h2>



    </header>
    

    
    <div class="article-meta">
      <a href="/2020/11/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" class="article-date">
  <time datetime="2020-11-26T09:50:43.000Z" itemprop="datePublished">2020-11-26</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
      <h2 id="网络七层协议模型（OSI）"><a href="#网络七层协议模型（OSI）" class="headerlink" title="网络七层协议模型（OSI）"></a>网络七层协议模型（OSI）</h2><ol>
<li>应用层: 与其它计算机进行通讯的一个应用，它是对应应用程序的通信服务的，比如<strong>HTTP、网络管理（SNMP简单网络管理协议），远程登录（Telnet），文件传输（TFTP）、域名系统（DNS）</strong></li>
<li>表示层: 这一层的主要功能是定义数据格式及加密，可以选择二进制或ASCII格式传输，比如，<strong>加密，ASCII</strong>等</li>
<li>会话层：它定义了如何开始、控制和结束一个会话，包括对多个双向消息的控制和管理，以便在只完成连续消息的一部分时可以通知应用，从而使表示层看到的数据是连续的，在会话层及以上的高层次中，数据传送的单位不再另外命名，而是统称为报文。示例：<strong>RPC，SSL、TSL</strong></li>
<li>传输层: 这层的功能包括是否选择差错恢复协议还是无差错恢复协议，及在同一主机上对不同应用的数据流的输入进行复用，还包括对收到的顺序不对的数据包的重新排序功能。示例：TCP，UDP，SPX。这一层的数据单元也称作数据包(packets)。但是，当你谈论TCP等具体的协议时又有特殊的叫法，TCP的数据单元称为段 (segments)而UDP协议的数据单元称为“数据报(datagrams)”。 <strong>TCP、UDP</strong></li>
<li>网络层: 这层对端到端的包传输进行定义，它定义了能够标识所有结点的逻辑地址，还定义了路由实现的方式和学习的方式。为了适应最大传输单元长度小于包长度的传输介质，网络层还定义了如何将一个包分解成更小的包的分段方法。示例：<strong>Internet协议（IP）、Internet控制信息协议（ICMP）、地址解析协议（ARP）</strong>等。在这一层，数据的单位称为数据包(packet)。</li>
<li>数据链路层: 它定义了在单个链路上如何传输数据。这些协议与被讨论的各种介质有关。示例：<strong>ATM，FDDI</strong>等。在这一层，数据的单位称为帧(frame)。</li>
<li>物理层: OSI的物理层规范是有关传输介质的特这些规范通常也参考了其他组织制定的标准。连接头、帧、帧的使用、电流、编码及光调制等都属于各种物理层规范中的内容。物理层常用多个规范完成对所有细节的定义。示例：<strong>Rj45，802.3</strong>等。这一层，数据单位是比特（bit）</li>
</ol>
<h2 id="TCP与UDP的区别"><a href="#TCP与UDP的区别" class="headerlink" title="TCP与UDP的区别"></a>TCP与UDP的区别</h2><ol>
<li>基于连接与无连接</li>
<li>对系统资源的要求（TCP较多，UDP少）</li>
<li>UDP程序结构较简单；</li>
<li>流模式与数据报模式 ；</li>
<li>TCP保证数据正确性，UDP可能丢包；</li>
<li>TCP保证数据顺序，UDP不保证。</li>
</ol>
<h2 id="HTTP与HTTPS的区别"><a href="#HTTP与HTTPS的区别" class="headerlink" title="HTTP与HTTPS的区别"></a>HTTP与HTTPS的区别</h2><p>HTTPS 经由 HTTP 进行通信，但利用 SSL/TLS 来加密数据包。HTTPS 开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。</p>
<ol>
<li>HTTP 明文传输，数据都是未加密的，安全性较差，HTTPS（SSL+HTTP） 数据传输过程是加密的，安全性较好。</li>
<li>使用 HTTPS 协议需要到 CA（Certificate Authority，数字证书认证机构） 申请证书，一般免费证书较少，因而需要一定费用。证书颁发机构如：Symantec、Comodo、GoDaddy 和 GlobalSign 等。</li>
<li>HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS除了 TCP 的三个包，还要加上 ssl 握手需要的 9 个包，所以一共是 12 个包。</li>
<li>HTTP 和HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。</li>
<li>HTTPS 其实就是建构在 SSL/TLS 之上的 HTTP 协议，所以，要比较 HTTPS 比 HTTP 要更耗费服务器资源。</li>
</ol>
<h2 id="get-post区别"><a href="#get-post区别" class="headerlink" title="get/post区别"></a>get/post区别</h2><ul>
<li><strong>请求参数</strong>：GET请求参数是通过URL传递的，多个参数以&amp;连接，POST请求放在request body中。</li>
<li><strong>请求缓存</strong>：GET请求会被缓存，而POST请求不会，除非手动设置。</li>
<li><strong>收藏为书签</strong>：GET请求支持，POST请求不支持。</li>
<li><strong>安全性</strong>：POST比GET安全，GET请求在浏览器回退时是无害的，而POST会再次请求。</li>
<li><strong>历史记录</strong>：GET请求参数会被完整保留在浏览历史记录里，而POST中的参数不会被保留。</li>
<li><strong>编码方式</strong>：GET请求只能进行url编码，而POST支持多种编码方式。</li>
<li><strong>对参数的数据类型</strong>：GET只接受ASCII字符，而POST没有限制。</li>
</ul>
<h2 id="从输入url到展示网页发生了什么？"><a href="#从输入url到展示网页发生了什么？" class="headerlink" title="从输入url到展示网页发生了什么？"></a>从输入url到展示网页发生了什么？</h2><ul>
<li>域名解析，找到网址对应的IP地址</li>
<li>向服务器发送HTTP请求</li>
<li>建立TCP链接</li>
<li>服务器重定向响应，可能会经历nginx反向代理，域名转发等等</li>
<li>服务器处理请求，返回响应内容，一般会先返回主文件index.html</li>
<li>浏览器解析HTML文件，生成DOM树</li>
<li>异步加载静态资源（CSS、图片、iconfont等等），静态资源一般会放到CDN上存储，允许浏览器进行缓存。生成渲染树</li>
<li>DOM树和渲染树都加载完毕时，进行绘制</li>
<li>这个过程一旦遇到js文件，正常情况下要挂起html解析线程，去加载并执行js文件内容，但是可以通过defer或async，让加载可以异步请求，二者的区别是defer是将执行推迟到html文档解析完成， async是异步加载完立即执行</li>
</ul>
<p>JS单线程运行<br>EventLoop 时间循环队列<br>宏任务、微任务</p>
<h2 id="浏览器架构"><a href="#浏览器架构" class="headerlink" title="浏览器架构"></a>浏览器架构</h2><h3 id="单进程浏览器时代"><a href="#单进程浏览器时代" class="headerlink" title="单进程浏览器时代"></a>单进程浏览器时代</h3><p>单进程浏览器是指浏览器所以模块都运行再同一个进程里，这些模块包含了网络、插件、JavaScript 运行环境、渲染引擎和页面等</p>
<p><strong>缺点：</strong><br>不稳定性<br>不流畅<br>不安全</p>
<h3 id="目前的多进程架构"><a href="#目前的多进程架构" class="headerlink" title="目前的多进程架构"></a>目前的多进程架构</h3><ul>
<li><strong>浏览器主进程</strong>。主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。</li>
<li><strong>渲染进程</strong>。核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。</li>
<li><strong>GPU 进程</strong>。其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。</li>
<li><strong>网络进程</strong>。主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。</li>
<li><strong>插件进程</strong>。主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。</li>
</ul>
<p><strong>缺点：</strong></p>
<p><strong>更高的资源占</strong>用因为每个进程都会包含公共基础结构的副本（如 JavaScript 运行环境），这就意味着浏览器会消耗更多的内存资源。</p>
<p><strong>更复杂的体系架构</strong>浏览器各模块之间耦合性高、扩展性差等问题，会导致现在的架构已经很难适应新的需求了</p>
<h3 id="未来面向服务的架构"><a href="#未来面向服务的架构" class="headerlink" title="未来面向服务的架构"></a>未来面向服务的架构</h3><p>为了解决这些问题，在 2016 年，Chrome 官方团队使用“面向服务的架构”（Services Oriented Architecture，简称 SOA）的思想设计了新的 Chrome 架构<br>Chrome 最终要把 UI、数据库、文件、设备、网络等模块重构为基础服务，类似操作系统底层服务。</p>
<h2 id="渲染引擎（浏览器内核）"><a href="#渲染引擎（浏览器内核）" class="headerlink" title="渲染引擎（浏览器内核）"></a>渲染引擎（浏览器内核）</h2><ul>
<li><strong>GUI渲染线程</strong>：GUI 渲染线程负责渲染浏览器界面，解析 HTML，CSS，构建 DOM 树和 RenderObject 树，布局和绘制等。当界面需要重绘（Repaint）或由于某种操作引发回流（Reflow）时，该线程就会执行。</li>
<li><strong>JavaScript引擎线程</strong>: JavaScript 引擎线程主要负责解析 JavaScript 脚本并运行相关代码。 JavaScript 引擎在一个Tab页（Renderer 进程）中无论什么时候都只有一个 JavaScript 线程在运行 JavaScript 程序。需要提起一点就是，GUI线程与JavaScript引擎线程是互斥的，这也是就是为什么JavaScript操作时间过长，会造成页面渲染不连贯，导致页面出现阻塞的原理</li>
<li><strong>事件触发线程</strong>：当一个事件被触发时该线程会把事件添加到待处理队列的队尾，等待 JavaScript 引擎的处理。 通常JavaScript引擎是单线程的，所以这些事件都会排队等待JS执行</li>
<li><strong>定时器触发器</strong>： 我们日常使用的setInterval 和 setTimeout 就在该线程中，原因可能就是：由于JS引擎是单线程的，如果处于阻塞线程状态就会影响记时的准确，所以需要通过单独的线程来记时并触发响应的事件这样子更为合理</li>
<li><strong>Http请求线程</strong>： 在 XMLHttpRequest 在连接后是通过浏览器新开一个线程请求，这个线程就Http请求线程，它将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件放到 JavaScript 引擎的处理队列中等待处理</li>
</ul>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6846687590540640263">浏览器架构</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903489596833800">HTTP发展历史</a></li>
<li><a target="_blank" rel="noopener" href="https://heapdump.cn/article/3576099">性能优化之html、css、js三者的加载顺序</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/11/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" data-id="clpuo0yvk000kotmuda8ra5zn" class="article-share-link">
        Share
      </a>
      
    </footer>

  </div>

  

  

</article>
    
    <article id="post-Git指令" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h2 itemprop="name">
  <a class="article-title" href="/2020/11/06/Git%E6%8C%87%E4%BB%A4/">git指令</a>
</h2>



    </header>
    

    
    <div class="article-meta">
      <a href="/2020/11/06/Git%E6%8C%87%E4%BB%A4/" class="article-date">
  <time datetime="2020-11-06T09:50:43.000Z" itemprop="datePublished">2020-11-06</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
      <h2 id="一、git配置相关操作"><a href="#一、git配置相关操作" class="headerlink" title="一、git配置相关操作"></a>一、git配置相关操作</h2><h3 id="查看本地git用户信息"><a href="#查看本地git用户信息" class="headerlink" title="查看本地git用户信息"></a>查看本地git用户信息</h3><p>git config user.name</p>
<p>git config user.email</p>
<h3 id="配置本地git用户信息"><a href="#配置本地git用户信息" class="headerlink" title="配置本地git用户信息"></a>配置本地git用户信息</h3><p>git config –global user.name “username”</p>
<p>git config –global user.email “email”</p>
<p>生成密钥对：<code>ssh-keygen -t rsa -C &quot;邮箱&quot;</code></p>
<p>复制公钥内容： <code>clip &lt; ~/.ssh/id_rsa.pub</code></p>
<p>【备注】<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/b6bd61e1bc5f">多账户配置流程</a>，主要是为多个邮箱账号生成ssh密钥对</p>
<h3 id="查看不同级别的git-config"><a href="#查看不同级别的git-config" class="headerlink" title="查看不同级别的git config"></a>查看不同级别的git config</h3><table>
<thead>
<tr>
<th align="center">级别</th>
<th>文件存储位置</th>
<th>查看命令</th>
<th>优先级</th>
</tr>
</thead>
<tbody><tr>
<td align="center">系统级别</td>
<td>/etc/gitconfig</td>
<td>git config –system –list</td>
<td>最低</td>
</tr>
<tr>
<td align="center">用户级别</td>
<td>~/.gitconfig</td>
<td>git config –global –list</td>
<td>中</td>
</tr>
<tr>
<td align="center">项目级别</td>
<td>.git/config</td>
<td>git config –local –list</td>
<td>最高</td>
</tr>
</tbody></table>
<p><strong>【备注】所以当我们想单独配置某个项目的user.name user.email 以及远程仓库地址, 都可以通过修改项目的.git/config文件实现，可以实现一台电脑同时使用多个github账号</strong></p>
<h2 id="二、远端拷贝"><a href="#二、远端拷贝" class="headerlink" title="二、远端拷贝"></a>二、远端拷贝</h2><h3 id="拉取git仓库"><a href="#拉取git仓库" class="headerlink" title="拉取git仓库"></a>拉取git仓库</h3><h4 id="git-fetch-origin-master-tmp"><a href="#git-fetch-origin-master-tmp" class="headerlink" title="git fetch origin master:tmp"></a><code>git fetch origin master:tmp</code></h4><p>在本地新建一个tmp分支，并将远程origin仓库的master分支代码下载到本地tmp分支</p>
<h4 id="git-clone-b-分支名-远程库地址-本地目录名"><a href="#git-clone-b-分支名-远程库地址-本地目录名" class="headerlink" title="git clone [-b 分支名] 远程库地址 本地目录名"></a><code>git clone [-b 分支名] 远程库地址 本地目录名</code></h4><p>将远程仓库拷贝到本地指定目录，并新建分支</p>
<h4 id="git-pull-仓库别名-仓库分支名称"><a href="#git-pull-仓库别名-仓库分支名称" class="headerlink" title="git pull 仓库别名 仓库分支名称"></a><code>git pull 仓库别名 仓库分支名称</code></h4><p>拉取远端更新内容</p>
<h3 id="将已有项目添加到远程git仓库"><a href="#将已有项目添加到远程git仓库" class="headerlink" title="将已有项目添加到远程git仓库"></a>将已有项目添加到远程git仓库</h3><h4 id="git-remote-add-origin-远程仓库地址"><a href="#git-remote-add-origin-远程仓库地址" class="headerlink" title="git remote add origin 远程仓库地址"></a><code>git remote add origin 远程仓库地址</code></h4><p>给本地项目添加远程仓库地址</p>
<h4 id="git-remote-v"><a href="#git-remote-v" class="headerlink" title="git remote -v"></a><code>git remote -v</code></h4><p>查看远程仓库</p>
<h4 id="git-push-仓库别名-仓库分支名称"><a href="#git-push-仓库别名-仓库分支名称" class="headerlink" title="git push 仓库别名 仓库分支名称"></a><code>git push 仓库别名 仓库分支名称</code></h4><p>将本地更新推送到远端</p>
<h4 id="git-pull-origin-master-–allow-unrelated-histories"><a href="#git-pull-origin-master-–allow-unrelated-histories" class="headerlink" title="git pull origin master –allow-unrelated-histories"></a><code>git pull origin master –allow-unrelated-histories</code></h4><p><font color=Blue><strong>【备注】远程仓库和本地仓库分别创建的时候直接pull会出现错误，refusing to merge unrelated histories，这个时候就要使用–allow-unrelated-histories参数来解决(可以合并两个独立启动仓库的历史)</strong></font></p>
<h2 id="三、本地的工作区和版本库"><a href="#三、本地的工作区和版本库" class="headerlink" title="三、本地的工作区和版本库"></a>三、本地的工作区和版本库</h2><h3 id="版本库包括暂存区和本地分支"><a href="#版本库包括暂存区和本地分支" class="headerlink" title="版本库包括暂存区和本地分支"></a>版本库包括暂存区和本地分支</h3><p><img src="https://github.com/QhdJiaYou/Image/blob/master/gitOverview.png?raw=true" alt="avatar"></p>
<p>git add把文件添加进去，实际上就是把<strong>文件修改</strong>添加到<strong>暂存区</strong>；</p>
<p>git commit提交更改，实际上就是把<strong>暂存区</strong>的所有内容提交到<strong>当前分支</strong>。</p>
<h3 id="恢复暂存区的指定文件到工作区"><a href="#恢复暂存区的指定文件到工作区" class="headerlink" title="恢复暂存区的指定文件到工作区"></a>恢复暂存区的指定文件到工作区</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout [fileName]</span><br><span class="line">git checkout -- [fileName] // -- 表示后面的内容是文件，是为了避免指令和文件名相同时的冲突，例如rm -f 和rm -- -f，后面的指令是删除名为-f的文件</span><br><span class="line">git checkout . //恢复暂存区的所有文件到工作区</span><br></pre></td></tr></table></figure>
<h3 id="删除本地分支"><a href="#删除本地分支" class="headerlink" title="删除本地分支"></a>删除本地分支</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -D branchName  或 git branch -d branchName  // D是强制删除</span><br></pre></td></tr></table></figure>
<h3 id="比较差异Diff"><a href="#比较差异Diff" class="headerlink" title="比较差异Diff"></a>比较差异Diff</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git diff [filePath] // 比较working和stage</span><br><span class="line">git diff HEAD // 显示working与commit的差异</span><br><span class="line">git diff --cached：是查看stage与commit的差别的</span><br><span class="line">git diff HEAD^ // 是比较working与上次commit</span><br><span class="line">git diff HEAD~n</span><br></pre></td></tr></table></figure>
<h3 id="git新增——git-switch和git-restore"><a href="#git新增——git-switch和git-restore" class="headerlink" title="git新增——git switch和git restore"></a>git新增——git switch和git restore</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b [branchName] 等同于 git switch -c [branchName]</span><br><span class="line">git restore -- [fileName] 等同于 git checkout -- [fileName]</span><br></pre></td></tr></table></figure>
<h3 id="重置代码"><a href="#重置代码" class="headerlink" title="重置代码"></a>重置代码</h3><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903614767448072">git reset和git revert操作的区别</a></p>
<p>实现手段不同，git reset是通过操作修改当前commit指针指向，操作后，某次commit之后的所有commit都会被去掉</p>
<p>而git revert是通过新增一次commit来抵消之前某次commit的修改，原本的修改仍然还在，可以达到只去除某一次commit的效果</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard // 修改指针123</span><br><span class="line">git reset --mixed  // 修改指针12，默认值</span><br><span class="line">git reset --soft //修改指针1</span><br><span class="line"></span><br><span class="line">//例子</span><br><span class="line">git reset --hard HEAD^  // 所有地方都修改成上一次commit</span><br></pre></td></tr></table></figure>
<p><img src="https://github.com/QhdJiaYou/Image/blob/master/gitResetWay.png?raw=true" alt="avatar"></p>
<h2 id="四、git实战经验"><a href="#四、git实战经验" class="headerlink" title="四、git实战经验"></a>四、git实战经验</h2><h3 id="git-pull-–rebase"><a href="#git-pull-–rebase" class="headerlink" title="git pull –rebase"></a>git pull –rebase</h3><p>使用场景: 拉取远端代码, 又不想产生新的merge commit记录</p>
<p>使用时两个注意点:</p>
<ul>
<li>执行 git pull –rebase 的时候必须保持本地目录干净。即：不能存在状态为 modified 的文件。（存在Untracked files是没关系的）</li>
<li>如果出现冲突，可以选择手动解决冲突后继续 rebase，也可以放弃本次 rebase</li>
</ul>
<p>解决本地文件修改</p>
<ul>
<li>如果本次修改已经完成，则可以先提交（commit）一下</li>
<li>如果本次修改尚未完成，则可以先贮藏：git stash</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 把本地发生改动的文件贮藏一下</span></span><br><span class="line">git stash </span><br><span class="line"><span class="meta">#</span><span class="bash"> 把远程最新的 commit 以变基的方式同步到本地</span></span><br><span class="line">git pull --rebase</span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果存在冲突,一般是多人改了同一个地方, 手动修改冲突文件后执行</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add 冲突文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git rebase --<span class="built_in">continue</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 也可以执行git rebase --abort终止合并操作继续执行</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 把本地的 commit 推送到远程</span></span><br><span class="line">git push </span><br><span class="line"><span class="meta">#</span><span class="bash"> 把本地贮藏的文件弹出，继续修改</span></span><br><span class="line">git stash pop</span><br></pre></td></tr></table></figure>

<p><strong>【备注】使用rebase出现冲突,有一种情况是要避免的</strong></p>
<p>如果你本地N次commit都修改了同一个地方,且与远端被另外一个同学修改的地方有冲突</p>
<p>那么这个时候就需要手动解冲突N次</p>
<p>解决办法是, 直接使用git pull(git fetch + git merge)</p>
<p>或者本地先将多次commit合并, 再使用git pull –rebase</p>
<h3 id="打tag"><a href="#打tag" class="headerlink" title="打tag"></a>打tag</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git tag r-201013-8a2ceb-quhandong</span><br><span class="line">git push origin r-201013-8a2ceb-quhandong</span><br></pre></td></tr></table></figure>

<h3 id="常用命令行指令"><a href="#常用命令行指令" class="headerlink" title="常用命令行指令"></a>常用命令行指令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ctrl + w 往回删除一个单词，光标放在最末尾</span><br><span class="line">ctrl + u 删除光标以前的字符</span><br><span class="line">ctrl + k 删除光标以后的字符</span><br><span class="line">ctrl + a 移动光标至的字符头</span><br><span class="line">ctrl + e 移动光标至的字符尾</span><br><span class="line">ctrl + l 清屏</span><br></pre></td></tr></table></figure>










      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/11/06/Git%E6%8C%87%E4%BB%A4/" data-id="clpuo0yv70002otmucdr9a8ec" class="article-share-link">
        Share
      </a>
      
    </footer>

  </div>

  

  

</article>
    
    <article id="post-hash&amp;chunkhash&amp;contenthash区别" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h2 itemprop="name">
  <a class="article-title" href="/2020/11/06/hash&chunkhash&contenthash%E5%8C%BA%E5%88%AB/">webpack之hash、chunkhash、contenthash区别</a>
</h2>



    </header>
    

    
    <div class="article-meta">
      <a href="/2020/11/06/hash&chunkhash&contenthash%E5%8C%BA%E5%88%AB/" class="article-date">
  <time datetime="2020-11-06T09:50:43.000Z" itemprop="datePublished">2020-11-06</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
      <p>hash 计算与整个项目的构建相关</p>
<p>chunkhash 计算与同一 chunk 内容相关</p>
<p>contenthash 计算与文件内容本身相关</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/11/06/hash&chunkhash&contenthash%E5%8C%BA%E5%88%AB/" data-id="clpuo0yvd000aotmue5s9ejv2" class="article-share-link">
        Share
      </a>
      
    </footer>

  </div>

  

  

</article>
    
    <article id="post-前端模块化方案" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h2 itemprop="name">
  <a class="article-title" href="/2020/11/06/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%E6%96%B9%E6%A1%88/">前端模块化方案</a>
</h2>



    </header>
    

    
    <div class="article-meta">
      <a href="/2020/11/06/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%E6%96%B9%E6%A1%88/" class="article-date">
  <time datetime="2020-11-06T09:50:43.000Z" itemprop="datePublished">2020-11-06</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
      <h2 id="模块化方案介绍"><a href="#模块化方案介绍" class="headerlink" title="模块化方案介绍"></a>模块化方案介绍</h2><h3 id="1、CommonJS-Nodejs"><a href="#1、CommonJS-Nodejs" class="headerlink" title="1、CommonJS(Nodejs)"></a>1、CommonJS(Nodejs)</h3><p>模块的加载是同步的而且可以加载多次，但在第一次加载后就会被缓存，后面再次被加载时会直接从缓存中读取。CommonJS主要用于服务器Node.js编程</p>
<p><strong>module对象:</strong><br>每个模块内部都有一个module对象代表当前模块，module模块具有以下几个属性</p>
<ol>
<li>module.id:模块的标识符，通常是绝对路径的模块文件名</li>
<li>module.filename:模块的文件名。</li>
<li>module.loaded:一个布尔值，表示模块是否已经完成加载。</li>
<li>module.parent:一个数组，表示依赖该模块的模块。</li>
<li>module.children:一个数组，表示该模块依赖的模块。</li>
<li>module.exports:一个对象，表示模块向外暴露的内容</li>
</ol>
<p><strong>module.exports属性：</strong><font color="red">真正对外暴露的对象</font></p>
<p><strong>exports变量</strong>: CommonJS规范内置赋值操作<br><code>const exports = module.exports;</code></p>
<p><strong>暴露模块</strong><br><code>module.exports=value或者module.xxx=value</code></p>
<p><strong>引入模块</strong><br><code>require(xxx)</code></p>
<p>第一次执行：加载并执行；<br>后续执行：使用备份，原始依赖中的改变不会影响</p>
<p><strong>发生循环的位置剪断循环</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="built_in">exports</span>.x = <span class="string">&#x27;a1&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;a.js&#x27;</span>, <span class="built_in">require</span>(<span class="string">&#x27;./b.js&#x27;</span>).x);</span><br><span class="line"><span class="built_in">exports</span>.x.  = <span class="string">&#x27;a2&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="built_in">exports</span>.x = <span class="string">&#x27;b1&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;b.js&#x27;</span>, <span class="built_in">require</span>(<span class="string">&#x27;./a.js&#x27;</span>).x);</span><br><span class="line"><span class="built_in">exports</span>.x.  = <span class="string">&#x27;b2&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;main.js&#x27;</span>, <span class="built_in">require</span>(<span class="string">&#x27;./a.js&#x27;</span>).x);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;main.js&#x27;</span>, <span class="built_in">require</span>(<span class="string">&#x27;./b.js&#x27;</span>).x);</span><br></pre></td></tr></table></figure>

<p>输出内容</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b.js a1</span><br><span class="line">a.js b2</span><br><span class="line">main.js  a2</span><br><span class="line">main.js  b2</span><br></pre></td></tr></table></figure>

<p>加载a的时候去加载并执行b，执行b的时候又要去加载a, 在执行a文件第二行的时候发现循环引用，后面内容不再执行，所以b中拿到的x值是a1</p>
<h3 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h3><p>浏览器端一般采用AMD规范， 需要引用requirejs, 异步加载，加载后立即执行</p>
<p><strong>define函数的定义</strong> <code>define(id?,dependencies?,factory)</code></p>
<ol>
<li>id为字符串类型唯一用来标识模块（可以省略)</li>
<li>dependencies是一个数组字面量，用来表示当前定义的模块所依赖的模块（默认后缀名是.js)</li>
<li>factory是一个需要实例化的函数，函数的参数与依赖的模块一一对应，函数需要有返回值，函数的返回值表示当前模块暴露的内容。</li>
</ol>
<p><strong>require函数的定义</strong> <code>require(dependencies,factory)</code></p>
<ol>
<li>dependencies是一个数组字面量，表示调用的模块;</li>
<li>factory需要传入一个回调函数，用来说明模块异步加载完成后执行的操作。</li>
</ol>
<p><strong>配置require对象</strong>: require函数本身也是一个对象，它带有一个config函数用来配置require函数的运行参数</p>
<ol>
<li>baseUrl: 即本地模块的路径是相对于哪个目录的</li>
<li>paths: paths参数指定各个模块的位置。这个位置可以是服务器上的相对位置，也可以是外部源。可以为每个模块定义多个位置，如果第一个位置加载失败，则加载第二个位置</li>
<li>shim: 有些库不是AMD兼容的，这时就需要指定shim属性的值。shim是用来帮助require.js加载非AMD规范的库。</li>
</ol>
<h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><p>CMD全称是Common Module Definition，它整合了CommonJS和AMD规范的特点，专门用于浏览器端，异步加载模块。该规范明确了模块的书写格式和基本交互规则。</p>
<p><strong>定义模块语法</strong>：<code>define(factory)</code></p>
<p>factory的取值可以是函数或者任何合法的值（对象、数组、字符串等）</p>
<p>当factory是函数时，表示是该模块的构造函数，这个函数具有三个参数：“require、exports、module”。</p>
<ol>
<li>require参数是一个方法，它接受模块唯一标识作为参数，用来引入依赖。</li>
<li>exports参数用来暴露模块</li>
<li>module参数指向当前模块。</li>
</ol>
<h3 id="UMD"><a href="#UMD" class="headerlink" title="UMD"></a>UMD</h3><p>是一种兼容commonjs、amd、cmd、的模块加载方案</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">root, factory</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">module</span> === <span class="string">&#x27;object&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">module</span>.exports === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;是commonjs模块规范，nodejs环境&#x27;</span>)</span><br><span class="line">        <span class="keyword">var</span> depModule = <span class="built_in">require</span>(<span class="string">&#x27;./umd-module-depended&#x27;</span>)</span><br><span class="line">        <span class="built_in">module</span>.exports = factory(depModule);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">&#x27;function&#x27;</span> &amp;&amp; define.amd) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;是AMD模块规范，如require.js&#x27;</span>)</span><br><span class="line">        define([<span class="string">&#x27;depModule&#x27;</span>], factory)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">&#x27;function&#x27;</span> &amp;&amp; define.cmd) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;是CMD模块规范，如sea.js&#x27;</span>)</span><br><span class="line">        define(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> depModule = <span class="built_in">require</span>(<span class="string">&#x27;depModule&#x27;</span>)</span><br><span class="line">            <span class="built_in">module</span>.exports = factory(depModule)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;没有模块环境，直接挂载在全局对象上&#x27;</span>)</span><br><span class="line">        root.umdModule = factory(root.depModule);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;(<span class="built_in">this</span>, <span class="function"><span class="keyword">function</span>(<span class="params">depModule</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;我调用了依赖模块&#x27;</span>, depModule)</span><br><span class="line">	<span class="comment">// ...省略了一些代码，去代码仓库看吧</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;我自己是一个umd模块&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="ESM"><a href="#ESM" class="headerlink" title="ESM"></a>ESM</h3><p>ES6 Module模块加载方案，推荐参考<a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/module">ECMAScript 6 入门-Module语法</a></p>
<h2 id="模块化方案对比"><a href="#模块化方案对比" class="headerlink" title="模块化方案对比"></a>模块化方案对比</h2><table>
<thead>
<tr>
<th></th>
<th>CommonJS</th>
<th>AMD</th>
<th>CMD</th>
<th align="left">ES6 module</th>
</tr>
</thead>
<tbody><tr>
<td>全称</td>
<td></td>
<td>Async module definition</td>
<td>Common module definition</td>
<td align="left"></td>
</tr>
<tr>
<td>使用场景</td>
<td>服务端</td>
<td>前端</td>
<td>前端</td>
<td align="left">前端</td>
</tr>
<tr>
<td>加载方式</td>
<td>运行时同步加载</td>
<td>运行时异步加载</td>
<td>运行时异步加载</td>
<td align="left">编译时静态加载</td>
</tr>
<tr>
<td>导出模块</td>
<td>module.exports或exports</td>
<td>define(moduleName?,[dependency?],factory)</td>
<td>define(factory)</td>
<td align="left">export或export default</td>
</tr>
<tr>
<td>优缺点</td>
<td>输出的是值的拷贝，输出之后，模块内部的变化不会影响输出</td>
<td>并行加载，加载速度快，不能保证加载顺序</td>
<td>懒加载，使用时才会执行，顺序可控，依赖打包工具spm</td>
<td align="left">输出的是值的引用，模块内部的变化会影响输出</td>
</tr>
<tr>
<td>实现</td>
<td>nodejs</td>
<td>requirejs</td>
<td>seajs</td>
<td align="left">ES6</td>
</tr>
</tbody></table>
<h5 id="以上几种模块打包对比总结："><a href="#以上几种模块打包对比总结：" class="headerlink" title="以上几种模块打包对比总结："></a>以上几种模块打包对比总结：</h5><ul>
<li>CommonJS规范主要用于服务端编程，加载模块是同步的，这并不适合在浏览器环境，因为同步意味着阻塞加载，浏览器资源是异步加载的，因此有了AMD、CMD解决方案。</li>
<li>AMD规范在浏览器环境中异步加载模块，而且可以并行加载多个模块。不过，AMD规范开发成本高，代码的阅读和书写比较困难，模块定义方式的语义不顺畅。</li>
<li>CMD规范与AMD规范很相似，都用于浏览器编程，依赖就近，延迟执行，可以很容易在Node.js中运行。但是依赖SPM打包，模块的加载逻辑偏重。</li>
<li>ES6在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代CommonJS和 CMD规范，成为浏览器和服务器通用的模块化解决方案。</li>
</ul>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_41631970/article/details/89467548">前端模块化规范</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/c9b29520fc6e">Commonjs规范中module.exports和exports的区别</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/11/06/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%E6%96%B9%E6%A1%88/" data-id="clpuo0yvg000eotmu1r368rkd" class="article-share-link">
        Share
      </a>
      
    </footer>

  </div>

  

  

</article>
    
    <article id="post-Eslint插件开发" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h2 itemprop="name">
  <a class="article-title" href="/2020/09/27/Eslint%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/">ESlint插件开发</a>
</h2>



    </header>
    

    
    <div class="article-meta">
      <a href="/2020/09/27/Eslint%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/" class="article-date">
  <time datetime="2020-09-27T07:50:43.000Z" itemprop="datePublished">2020-09-27</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
      <h2 id="解析器调研"><a href="#解析器调研" class="headerlink" title="解析器调研"></a>解析器调研</h2><p>将JS/TS解析成AST结构的语法树，有很多解析工具，每种解析工具解析出来的大体结构类似，但是节点命名各有特色</p>
<p>解析器对注释内容支持程度对比</p>
<table>
<thead>
<tr>
<th align="center">解析器</th>
<th>@babel/parser</th>
<th>@typescript-eslint/parser</th>
<th>tsquery</th>
<th>typescript</th>
</tr>
</thead>
<tbody><tr>
<td align="center">解析注释</td>
<td>是</td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td align="center">区分块注释和行注释</td>
<td>是</td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td align="center">解析TS</td>
<td>否</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
</tbody></table>
<p>经过对比发现，我们只能使用tsquery 或者typescript ，<br>但是，TSquery相比typescript自带的解析工具有更加优秀的地方</p>
<ul>
<li>当需要查找满足条件的子级的 ast 节点时，需要做多次比较</li>
<li>对满足某一条件的多个不同类型的节点需要比较多次，编写满足条件麻烦</li>
<li>对分布在同一文件中的多个同名标识符，不能统一提取和处理</li>
</ul>
<h2 id="使用TSquery"><a href="#使用TSquery" class="headerlink" title="使用TSquery"></a>使用TSquery</h2><p>建议使用<a target="_blank" rel="noopener" href="https://astexplorer.net/%E7%BA%BF%E4%B8%8A%E8%A7%A3%E6%9E%90%E5%B7%A5%E5%85%B7%EF%BC%8C%E9%80%89%E6%8B%A9typescript%E8%A7%A3%E6%9E%90%E5%99%A8%E8%A7%A3%E6%9E%90ts%E4%BB%A3%E7%A0%81%EF%BC%8C%E5%BE%97%E5%88%B0%E7%9A%84ast%E7%BB%93%E6%9E%84%E4%B8%8Etsquery%E7%9A%84%E7%9B%B8%E5%90%8C">https://astexplorer.net/线上解析工具，选择typescript解析器解析ts代码，得到的ast结构与tsquery的相同</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tsquery = <span class="built_in">require</span>(<span class="string">&#x27;@phenomnomnominal/tsquery&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> ts = <span class="built_in">require</span>(<span class="string">&#x27;ntypescript&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> tsQueryAst = tsquery.tsquery.ast(srcCode); </span><br><span class="line"><span class="keyword">const</span> ast = ts.createSourceFile(<span class="string">&#x27;foo.ts&#x27;</span>, srcCode, ts.ScriptTarget.ES5, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<p>使用tsquery构建AST语法树，本质上就是调用ts的createSourcefile，所以tsquery生成的ast结构与typescript解析后的结构相同</p>
<h2 id="eslintrc-js配置信息"><a href="#eslintrc-js配置信息" class="headerlink" title="eslintrc.js配置信息"></a>eslintrc.js配置信息</h2><p>官方文档：</p>
<ul>
<li>英文：<a target="_blank" rel="noopener" href="https://eslint.org/docs/user-guide/configuring">https://eslint.org/docs/user-guide/configuring</a></li>
<li>中文：<a target="_blank" rel="noopener" href="https://cn.eslint.org/docs/user-guide/configuring">https://cn.eslint.org/docs/user-guide/configuring</a></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 因为eslint生效规则是内层优先，这个配置告诉eslint找当前配置文件不需要往父级查找</span></span><br><span class="line">  <span class="attr">root</span>: <span class="literal">true</span>, </span><br><span class="line">  <span class="comment">/** </span></span><br><span class="line"><span class="comment">  *  ESlint会检测未声明的变量，并发出告警，但是有些变量是我们引入的第三方库声明的，此时就需要提前在配置中声明</span></span><br><span class="line"><span class="comment">  * &#x27;readonly&#x27; 或 false - 表示该全局变量是只读的</span></span><br><span class="line"><span class="comment">  * ‘writeable&#x27; 或 true - 表示该全局变量是可写可读的</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="attr">globals</span>: &#123; <span class="comment">// 指定全局变量是只读的还是可写的</span></span><br><span class="line">    <span class="attr">$</span>: <span class="literal">false</span>, <span class="comment">// jQuery对象</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 不同环境下，全局变量各有不同，env提供对一个环境定义的一组全局变量的预设，避免了我们一个一个的在globals中声明</span></span><br><span class="line">  <span class="attr">env</span>: &#123; </span><br><span class="line">    <span class="attr">browser</span>: <span class="literal">true</span>, <span class="comment">// 浏览器环境,console属性只有在浏览器环境下才有定义，如果不支持browser环境，会出现console is undefined</span></span><br><span class="line">    <span class="attr">es6</span>: <span class="literal">true</span>, <span class="comment">// ES6环境, 如果不支持，就无法正常识别es6的特殊语法，比如const</span></span><br><span class="line">    <span class="attr">node</span>: <span class="literal">true</span>, <span class="comment">// node环境,比如__dirname变量</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">extends</span>: [ <span class="comment">// 插件中config字段配置好的规则集合，往往是最佳实践,它配置的内容实际就是一份份别人配置好的.eslintrc.js</span></span><br><span class="line">    <span class="string">&#x27;@wmfe/eslint-config-mt/eslintrc.react.js&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;@wmfe/eslint-config-mt/eslintrc.typescript-react.js&#x27;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">plugins</span>: [ <span class="comment">// 插件名称，省略前缀eslint-plugin-，可以灵活结合rules开启校验规则</span></span><br><span class="line">    <span class="string">&#x27;react&#x27;</span>,</span><br><span class="line">  ],</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  &quot;off&quot; 或 0 - 关闭规则</span></span><br><span class="line"><span class="comment">	&quot;warn&quot; 或 1 - 开启规则，使用警告级别的错误：warn (不会导致程序退出)</span></span><br><span class="line"><span class="comment">	&quot;error&quot; 或 2 - 开启规则，使用错误级别的错误：error (当被触发的时候，程序会退出)</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="attr">rules</span>: &#123; <span class="comment">// 开启plugins中规则检查能力需要配置rules, &quot;off&quot;或0（关闭规则）&quot;warn&quot;或1（开启警告规则）“error”或2（开启错误规则）</span></span><br><span class="line">    <span class="string">&#x27;eslint-plugin-react/jsx-boolean-value&#x27;</span>: [<span class="string">&quot;error&quot;</span>],</span><br><span class="line">    <span class="string">&quot;no-restricted-globals&quot;</span>: [ <span class="comment">// 有些插件规则支持参数配置，数组中可以传递参数</span></span><br><span class="line">            <span class="string">&quot;error&quot;</span>,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">&quot;name&quot;</span>: <span class="string">&quot;event&quot;</span>,</span><br><span class="line">                <span class="string">&quot;message&quot;</span>: <span class="string">&quot;Use local parameter instead.&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">&quot;name&quot;</span>: <span class="string">&quot;fdescribe&quot;</span>,</span><br><span class="line">                <span class="string">&quot;message&quot;</span>: <span class="string">&quot;Do not commit fdescribe. Use describe instead.&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">overrides</span>: [ <span class="comment">// 配置特定文件类型进行规则校验，比如下面的规则只对ts文件校验</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;files&quot;</span>: [<span class="string">&quot;*.ts&quot;</span>, <span class="string">&quot;*.tsx&quot;</span>],</span><br><span class="line">      <span class="string">&quot;rules&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;@typescript-eslint/explicit-function-return-type&#x27;</span>: <span class="number">2</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="comment">// 用来指定eslint解析器的，使用什么方式解析成ast语法树</span></span><br><span class="line">  <span class="comment">// espima(默认)</span></span><br><span class="line">  <span class="comment">// babel最先推出支持ES6语法的babel-eslint, 让ESlint逐渐火了起来</span></span><br><span class="line">  <span class="comment">// @typescript-eslint/parser 是TS团队实现的</span></span><br><span class="line">  <span class="attr">parser</span>:<span class="string">&quot;@typescript-eslint/parser&quot;</span>,</span><br><span class="line">  <span class="attr">parserOptions</span>: &#123; <span class="comment">// 解析器配置参数</span></span><br><span class="line">    <span class="attr">ecmaFeatures</span>: &#123;</span><br><span class="line">      <span class="attr">globalReturn</span>: <span class="literal">true</span>, <span class="comment">// 允许在全局作用域下使用return语句</span></span><br><span class="line">      <span class="attr">impliedStrict</span>: <span class="literal">true</span>, <span class="comment">// 启用全局 strict mode</span></span><br><span class="line">      <span class="attr">jsx</span>: <span class="literal">true</span>, <span class="comment">// 启用jsx</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">ecmaVersion</span>: <span class="number">2018</span>, <span class="comment">// es版本号，默认为5，也可以用年份，比如2015（同6）</span></span><br><span class="line">    <span class="attr">sourceType</span>: <span class="string">&#x27;module&#x27;</span>, <span class="comment">// js的导入方式，默认是script</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">settings</span>:&#123; <span class="comment">// 提供给每一个将被执行的规则,如果你想添加的自定义规则而且使它们可以访问到相同的信息，这将会很有用，并且很容易配置。</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>env 可选的环境很多，预设值都在<a target="_blank" rel="noopener" href="https://github.com/eslint/eslint/blob/v6.0.1/conf/environments.js">这个文件</a>中进行定义，查看源码可以发现，其预设变量都引用自<a target="_blank" rel="noopener" href="https://github.com/sindresorhus/globals/blob/main/globals.json">globals包</a></p>
<p>配置扩展</p>
<p>可以通过eslint-plugin-react插件<a target="_blank" rel="noopener" href="https://github.com/jsx-eslint/eslint-plugin-react/blob/master/index.js">源码文件</a>看到，它默认实现了两种最佳实践all以及recommened</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  deprecatedRules,</span><br><span class="line">  <span class="attr">rules</span>: allRules,</span><br><span class="line">  <span class="attr">configs</span>: &#123; <span class="comment">// 配置可普遍通用的规则集合</span></span><br><span class="line">    <span class="attr">recommended</span>: &#123;</span><br><span class="line">      <span class="attr">plugins</span>: [</span><br><span class="line">        <span class="string">&#x27;react&#x27;</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">parserOptions</span>: &#123;</span><br><span class="line">        <span class="attr">ecmaFeatures</span>: &#123;</span><br><span class="line">          <span class="attr">jsx</span>: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">rules</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;react/display-name&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="string">&#x27;react/jsx-key&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="string">&#x27;react/jsx-no-comment-textnodes&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="string">&#x27;react/jsx-no-duplicate-props&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="string">&#x27;react/jsx-no-target-blank&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="string">&#x27;react/jsx-no-undef&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="string">&#x27;react/jsx-uses-react&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="string">&#x27;react/jsx-uses-vars&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="string">&#x27;react/no-children-prop&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="string">&#x27;react/no-danger-with-children&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="string">&#x27;react/no-deprecated&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="string">&#x27;react/no-direct-mutation-state&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="string">&#x27;react/no-find-dom-node&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="string">&#x27;react/no-is-mounted&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="string">&#x27;react/no-render-return-value&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="string">&#x27;react/no-string-refs&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="string">&#x27;react/no-unescaped-entities&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="string">&#x27;react/no-unknown-property&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="string">&#x27;react/no-unsafe&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="string">&#x27;react/prop-types&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="string">&#x27;react/react-in-jsx-scope&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="string">&#x27;react/require-render-return&#x27;</span>: <span class="number">2</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">all</span>: &#123;</span><br><span class="line">      <span class="attr">plugins</span>: [</span><br><span class="line">        <span class="string">&#x27;react&#x27;</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">parserOptions</span>: &#123;</span><br><span class="line">        <span class="attr">ecmaFeatures</span>: &#123;</span><br><span class="line">          <span class="attr">jsx</span>: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">rules</span>: activeRulesConfig</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用的时候，如果碰到和自己风格或者规范有冲突的规则，那直接在rules中重新定义就可以了</p>
<p>扩展一般支持三种类型：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.export = &#123;</span><br><span class="line">    <span class="attr">extends</span>: [</span><br><span class="line">        <span class="string">&#x27;eslint:recommended&#x27;</span>, <span class="comment">// eslint:开头是ESlint官方的扩展，一共有两个：eslint:recommended、eslint:all</span></span><br><span class="line">        <span class="string">&#x27;plugin:eslint-plugin-react/recommended&#x27;</span>, <span class="comment">// plugin: 开头的是扩展是插件类型，也可以直接在 plugins 属性中进行设置</span></span><br><span class="line">        <span class="string">&#x27;eslint-config-standard&#x27;</span>, <span class="comment">// 来自npm包，官方规定 npm 包的扩展必须以 eslint-config- 开头，使用时可以省略这个头，eslint-config-standard 可以直接简写成 standard</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/6844904035271573511#heading-3">AST抽象语法树入门</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/47d9b2a365c5">Esprima学习</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/6844903901292920846#heading-21">如何写eslint插件</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/09/27/Eslint%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/" data-id="clpuo0yv50001otmu0aqs6zvr" class="article-share-link">
        Share
      </a>
      
    </footer>

  </div>

  

  

</article>
    
    <article id="post-TS实践积累" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h2 itemprop="name">
  <a class="article-title" href="/2020/09/23/TS%E5%AE%9E%E8%B7%B5%E7%A7%AF%E7%B4%AF/">TS实践工程应用</a>
</h2>



    </header>
    

    
    <div class="article-meta">
      <a href="/2020/09/23/TS%E5%AE%9E%E8%B7%B5%E7%A7%AF%E7%B4%AF/" class="article-date">
  <time datetime="2020-09-23T09:50:43.000Z" itemprop="datePublished">2020-09-23</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
      <h2 id="tsconfig-json中配置选项说明"><a href="#tsconfig-json中配置选项说明" class="headerlink" title="tsconfig.json中配置选项说明"></a>tsconfig.json中配置选项说明</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span>: &#123;  <span class="comment">// 编译选项配置</span></span><br><span class="line">    <span class="attr">&quot;allowSyntheticDefaultImports&quot;</span>: <span class="literal">true</span>,  <span class="comment">// 允许从没有设置默认导出的模块中默认导入</span></span><br><span class="line">    <span class="attr">&quot;outDir&quot;</span>: <span class="string">&quot;build&quot;</span>,  <span class="comment">// 重定向输出目录，将ts文件编译成js文件的存放位置</span></span><br><span class="line">    <span class="attr">&quot;declaration&quot;</span>: <span class="literal">true</span>  <span class="comment">// true表示自动生成ts文件的类型声明文件（.d.ts文件），默认和js文件放在一起</span></span><br><span class="line">    <span class="string">&quot;module&quot;</span>: <span class="string">&quot;es6&quot;</span>,  <span class="comment">// 不同的选项会影响模块的导入导出方式,按照es6的模块解析方式</span></span><br><span class="line">    <span class="attr">&quot;target&quot;</span>: <span class="string">&quot;es5&quot;</span>,  <span class="comment">// 编译的目标js语法支持到es5</span></span><br><span class="line">    <span class="attr">&quot;lib&quot;</span>: [<span class="string">&quot;es2018&quot;</span>, <span class="string">&quot;dom&quot;</span>],  <span class="comment">// 在target的基础上，额外可用的新特性或者库</span></span><br><span class="line">    <span class="attr">&quot;sourceMap&quot;</span>: <span class="literal">true</span>,  <span class="comment">// 生成相应的 .map文件</span></span><br><span class="line">    <span class="attr">&quot;allowJs&quot;</span>: <span class="literal">true</span>,  <span class="comment">// 允许编译 javascript 文件</span></span><br><span class="line">    <span class="attr">&quot;jsx&quot;</span>: <span class="string">&quot;react&quot;</span>,  <span class="comment">// 在 .tsx文件里支持JSX： &quot;React&quot;或 &quot;Preserve&quot;</span></span><br><span class="line">    <span class="attr">&quot;moduleResolution&quot;</span>: <span class="string">&quot;node&quot;</span>,  <span class="comment">//模块解析策略，如何查找类型声明文件，可选node和classic</span></span><br><span class="line">    <span class="attr">&quot;rootDir&quot;</span>: <span class="string">&quot;./&quot;</span>,  <span class="comment">// 输出的目录结构</span></span><br><span class="line">    <span class="attr">&quot;noImplicitReturns&quot;</span>: <span class="literal">true</span>, <span class="comment">// 不是函数的所有返回情况都有返回值时报错</span></span><br><span class="line">    <span class="attr">&quot;noImplicitThis&quot;</span>: <span class="literal">true</span>, <span class="comment">// 当 this表达式的值为 any类型的时候，生成一个错误</span></span><br><span class="line">    <span class="attr">&quot;noImplicitAny&quot;</span>: <span class="literal">false</span>, <span class="comment">// 在表达式和声明上有隐含的 any类型时 不报错</span></span><br><span class="line">    <span class="attr">&quot;strictNullChecks&quot;</span>: <span class="literal">true</span>, <span class="comment">// 严格的 null检查模式</span></span><br><span class="line">    <span class="attr">&quot;experimentalDecorators&quot;</span>: <span class="literal">true</span>, <span class="comment">// 启用实验性的ES装饰器</span></span><br><span class="line">    <span class="attr">&quot;typeRoots&quot;</span>: [   <span class="comment">// 编译过程中，默认所有@types下面的包，都会被包含进来，如果指定了typeRoots，只有typeRoots下面(src/types)的包才会被包含进来,而不包含./node_modules/@types里面的包。</span></span><br><span class="line">      <span class="string">&quot;src/types&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;types&quot;</span>: [ <span class="comment">// 禁用自动引入@types包，自动引入指的是定义全局变量的声明文件中自动引入，如果是在模块中import React from &#x27;react&#x27;;TS仍然会查找node_modules和node_modules/@types文件夹下的react文件</span></span><br><span class="line">      <span class="string">&quot;node&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;baseUrl&quot;</span>: <span class="string">&quot;./&quot;</span>,  <span class="comment">// 解析非相对模块名的基准目录</span></span><br><span class="line">    <span class="attr">&quot;paths&quot;</span>: &#123;   <span class="comment">// 模块名到基于 baseUrl的路径映射的列表</span></span><br><span class="line">        <span class="attr">&quot;types/*&quot;</span>: [<span class="string">&quot;src/types/*&quot;</span>],</span><br><span class="line">        <span class="attr">&quot;utils/*&quot;</span>: [<span class="string">&quot;src/utils/*&quot;</span>],</span><br><span class="line">        <span class="attr">&quot;components/*&quot;</span>: [<span class="string">&quot;src/components/*&quot;</span>],</span><br><span class="line">        <span class="attr">&quot;@/*&quot;</span>: [<span class="string">&quot;src/*&quot;</span>],</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;,</span><br><span class="line">  <span class="attr">&quot;files&quot;</span>: [   <span class="comment">// 指定编译的入口文件，也就是这些文件所依赖的文件也会被编译</span></span><br><span class="line">    <span class="string">&quot;app.ts&quot;</span>,</span><br><span class="line">    <span class="string">&quot;foo.ts&quot;</span>,</span><br><span class="line">  ]</span><br><span class="line">  <span class="string">&quot;include&quot;</span>:[]    <span class="comment">// 指定待编译文件</span></span><br><span class="line">  <span class="string">&quot;exclude&quot;</span>: [   <span class="comment">// 排除待编译文件</span></span><br><span class="line">    <span class="string">&quot;node_modules&quot;</span>,</span><br><span class="line">    <span class="string">&quot;config&quot;</span>,</span><br><span class="line">    <span class="string">&quot;build&quot;</span>,</span><br><span class="line">    <span class="string">&quot;scripts&quot;</span>,</span><br><span class="line">    <span class="string">&quot;acceptance-tests&quot;</span>,</span><br><span class="line">    <span class="string">&quot;webpack&quot;</span>,</span><br><span class="line">    <span class="string">&quot;jest&quot;</span>,</span><br><span class="line">    <span class="string">&quot;src/setupTests.ts&quot;</span>,</span><br><span class="line">    <span class="string">&quot;test&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;types&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;typePatches&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="模块导入导出"><a href="#模块导入导出" class="headerlink" title="模块导入导出"></a>模块导入导出</h2><p>内部模块和外部模块</p>
<p>外部模块： 来自ECMAScript 2015的模块概念，一般情况下一个文件对应一个模块</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">declare <span class="built_in">module</span> <span class="string">&quot;buffer&quot;</span></span><br></pre></td></tr></table></figure>

<p>内部模块： TypeScript共享模块，声明对象变量类型用的，将声明变量放到不同的命名空间，防止命名冲突，ts1.5版本之后，使用namespace关键字</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">declare <span class="built_in">module</span> Buffer <span class="comment">//Pre-TS 1.5</span></span><br><span class="line">declare namespace Buffer</span><br></pre></td></tr></table></figure>

<h2 id="如何写声明文件"><a href="#如何写声明文件" class="headerlink" title="如何写声明文件"></a>如何写声明文件</h2><h3 id="1、全局变量的声明文件"><a href="#1、全局变量的声明文件" class="headerlink" title="1、全局变量的声明文件"></a>1、全局变量的声明文件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">declare <span class="keyword">var</span> <span class="comment">// 声明全局变量</span></span><br><span class="line">declare <span class="function"><span class="keyword">function</span> // 声明全局方法</span></span><br><span class="line"><span class="function"><span class="title">declare</span> <span class="title">class</span> // 声明全局类</span></span><br><span class="line"><span class="function"><span class="title">declare</span> <span class="title">enum</span>  // 声明全局枚举类型</span></span><br><span class="line"><span class="function"><span class="title">declare</span> <span class="title">namespace</span> // 声明（含有子属性的）全局对象</span></span><br><span class="line"><span class="function"><span class="title">interface</span></span></span><br><span class="line"><span class="function"><span class="title">type</span></span></span><br></pre></td></tr></table></figure>
<h3 id="2、给npm包写类型声明文件"><a href="#2、给npm包写类型声明文件" class="headerlink" title="2、给npm包写类型声明文件"></a>2、给npm包写类型声明文件</h3><p>npm 包的声明文件与全局变量的声明文件有很大区别。在 npm 包的声明文件中，使用 declare 不再会声明一个全局变量，而只会在当前文件中声明一个局部变量。只有在声明文件中使用 export 导出，然后在使用方 import 导入后，才会应用到这些类型声明</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="comment">// 导出变量，方法，类等</span></span><br><span class="line"><span class="keyword">export</span> namespace <span class="comment">// 导出含有子属性的对象</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="comment">// ES6默认导出，只有function、class 和 interface 可以直接默认导出，其它需要先定义，后导出</span></span><br><span class="line"><span class="keyword">export</span> = moduleName <span class="comment">// commonjs规范导出语法</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">as</span> namespace moduleName <span class="comment">//UMD规范的导出语法</span></span><br></pre></td></tr></table></figure>
<h3 id="3、理解lib-d-ts"><a href="#3、理解lib-d-ts" class="headerlink" title="3、理解lib.d.ts"></a>3、理解lib.d.ts</h3><p>当我们安装 TypeScript 时，会顺带安装一个 lib.d.ts 声明文件。这个文件包含 JavaScript 运行时以及 DOM 中存在各种常见的环境声明。</p>
<ul>
<li>它自动包含在 TypeScript 项目的编译上下文中；</li>
<li>它能让我们快速开始书写经过类型检查的 JavaScript 代码。</li>
<li>可通过配置noLib排除此类型声明文件</li>
</ul>
<h4 id="string-vs-String"><a href="#string-vs-String" class="headerlink" title="string vs. String"></a><strong>string vs. String</strong></h4><ul>
<li>string: 字符串类型</li>
<li>String: JS对象，可以通过new String(‘’)创建字符串对象，但是在TS类型声明文件中，String也表示接口的名字，里面包含了JS中的字符串对象属性和方法的类型声明</li>
</ul>
<h4 id="直接扩展全局变量"><a href="#直接扩展全局变量" class="headerlink" title="直接扩展全局变量"></a><strong>直接扩展全局变量</strong></h4><p>如果有第三方库扩展了全局变量，可是该全局变量的类型没有跟着更新，就会导致TS编译错误，此时就需要扩展全局变量</p>
<p>a、使用接口声明合并【项目中可以将扩展的全局变量的内容统一定义在名为global.d.ts的文件中】</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扩展String类型</span></span><br><span class="line">interface <span class="built_in">String</span>&#123;</span><br><span class="line">    <span class="attr">name</span>: string,</span><br><span class="line">    <span class="attr">foo</span>: <span class="function">(<span class="params">num: number</span>) =&gt;</span> string</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 扩展Window对象类型字段</span></span><br><span class="line">interface Window &#123;</span><br><span class="line">    <span class="attr">KNB</span>: any; <span class="comment">// h5 KNB</span></span><br><span class="line">    wx: any; <span class="comment">// 微信</span></span><br><span class="line">    YodaSeed: <span class="built_in">Function</span>;</span><br><span class="line">    hideEpassportModal: <span class="built_in">Function</span>;</span><br><span class="line">    hideYodaModal: <span class="built_in">Function</span>;</span><br><span class="line">    showErrorTip: <span class="built_in">Function</span>;</span><br><span class="line">    closeCouponModal: <span class="built_in">Function</span>;</span><br><span class="line">    wmSystemApi: any;</span><br><span class="line">    <span class="comment">// [key: string]: any; // Add index signature</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>b、也可以使用declare namespace 给已有的命名空间添加类型声明</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">declare namespace NodeJS &#123;</span><br><span class="line">    interface Global &#123;</span><br><span class="line">        <span class="attr">registered</span>: boolean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="在-npm-包或-UMD-库中扩展全局变量"><a href="#在-npm-包或-UMD-库中扩展全局变量" class="headerlink" title="在 npm 包或 UMD 库中扩展全局变量"></a>在 npm 包或 UMD 库中扩展全局变量</h4><p>对于一个 npm 包或者 UMD 库的声明文件，只有 export 导出的类型声明才能被导入。所以对于 npm 包或 UMD 库，如果导入此库之后会扩展全局变量，则需要使用另一种语法在声明文件中扩展全局变量的类型，那就是 declare global</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">declare <span class="built_in">global</span> &#123;</span><br><span class="line">    interface <span class="built_in">String</span> &#123;</span><br><span class="line">        sayHello(): string;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123;&#125;; <span class="comment">// 仍然需要导出一个空对象，用来告诉编译器这是一个模块的声明文件，而不是一个全局变量的声明文件</span></span><br></pre></td></tr></table></figure>

<h4 id="扩展原有模块类型-declare-module"><a href="#扩展原有模块类型-declare-module" class="headerlink" title="扩展原有模块类型 declare module"></a>扩展原有模块类型 declare module</h4><p>如果是需要扩展原有模块本省有声明文件，需要在类型声明文件中先引用原有模块，再使用 declare module 扩展原有模块</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">declare <span class="built_in">module</span> <span class="string">&#x27;*.png&#x27;</span>;</span><br><span class="line">declare <span class="built_in">module</span> <span class="string">&#x27;@dp/owl&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>declare module后面只写模块名，不写具体内容类型，代表其中任何内容都是any，编译器也不会报错</p>
<h2 id="项目应用场景"><a href="#项目应用场景" class="headerlink" title="项目应用场景"></a>项目应用场景</h2><h3 id="1、使用ts完善request"><a href="#1、使用ts完善request" class="headerlink" title="1、使用ts完善request"></a>1、使用ts完善request</h3><p>接口的返回值字段除了data都一样，所以我们可以使用泛型抽象出一个返回值的公用类型</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface ResponseData&lt;T&gt;&#123;</span><br><span class="line">    <span class="attr">msg</span>: string;</span><br><span class="line">    code: number;</span><br><span class="line">    data: T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义请求参数类型TReq和返回值中的data字段类型TRes，减少接口类型报错的问题，使得数据更加可控</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface IAjaxReq &#123;</span><br><span class="line">    &lt;TReq, TRes&gt;(url: string, params: TReq, options?: Request.Options): Promise&lt;TRes&gt;;</span><br><span class="line">&#125;</span><br><span class="line">const get: IAjaxReq = (url, params, options) =&gt; ajax(url, &#x27;get&#x27;, params, options);</span><br></pre></td></tr></table></figure>

<h3 id="2、统一setState处理"><a href="#2、统一setState处理" class="headerlink" title="2、统一setState处理"></a>2、统一setState处理</h3><p>多个input的value，统一setState处理，需要字段和改变的字符串内容，TS类型定义如下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">handleInputChange = <span class="function">(<span class="params">newStr: <span class="built_in">String</span>, nameField: InputName</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">        [nameField]: newStr,</span><br><span class="line">    &#125; <span class="keyword">as</span> Pick&lt;IState, InputName&gt;);</span><br><span class="line">    <span class="built_in">this</span>.checkForm();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、给props添加location-history-match等参数"><a href="#3、给props添加location-history-match等参数" class="headerlink" title="3、给props添加location,history,match等参数"></a>3、给props添加location,history,match等参数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">interface IProps <span class="keyword">extends</span> RouteComponentProps&lt;&#123;&#125;, StaticContext, CreditMallAwardsView&gt;&#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用ts编程可以带来的好处"><a href="#使用ts编程可以带来的好处" class="headerlink" title="使用ts编程可以带来的好处"></a>使用ts编程可以带来的好处</h2><ol>
<li>可以在开发调试阶段，更好的感知数据报错问题，比如名字写错，或者返回值类型出错的问题</li>
<li>还可以通过类型限定返回值的类型，避免后端返回值为空undefined情况，对前端数据渲染造成的问题，我们可以提前赋值空数组或者空对象</li>
<li>可以减少重复的代码，通过泛型的概念，将能够公共的部分抽象出来，从而降低代码的耦合性，这样不仅提高代码的灵活性、健壮性以及可读性，也方便后期的维护</li>
<li>很多接口问题，规范化ts开发后，代码里很容易就能找到接口相关参数类型，便于开发人员判断接口字段</li>
</ol>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a target="_blank" rel="noopener" href="https://www.typescriptlang.org/docs/handbook/compiler-options.html">官方文档</a></p>
<p><a target="_blank" rel="noopener" href="https://www.tslang.cn/docs/handbook/compiler-options.html">compilerOptions选项列表</a></p>
<p><a target="_blank" rel="noopener" href="https://www.tslang.cn/docs/handbook/module-resolution.html">模块解析</a></p>
<p><a target="_blank" rel="noopener" href="https://www.tslang.cn/docs/handbook/tsconfig-json.html#types-typeroots-and-types">@types 、typeRoot和types的区别</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/09/23/TS%E5%AE%9E%E8%B7%B5%E7%A7%AF%E7%B4%AF/" data-id="clpuo0yvc0008otmubu4b2bow" class="article-share-link">
        Share
      </a>
      
    </footer>

  </div>

  

  

</article>
    
    <article id="post-TS基础知识和概念" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h2 itemprop="name">
  <a class="article-title" href="/2020/09/01/TS%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%92%8C%E6%A6%82%E5%BF%B5/">TS基础知识和概念</a>
</h2>



    </header>
    

    
    <div class="article-meta">
      <a href="/2020/09/01/TS%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%92%8C%E6%A6%82%E5%BF%B5/" class="article-date">
  <time datetime="2020-09-01T09:50:43.000Z" itemprop="datePublished">2020-09-01</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
      <h2 id="字面量类型"><a href="#字面量类型" class="headerlink" title="字面量类型"></a>字面量类型</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bstring: <span class="string">&#x27;hello&#x27;</span> | <span class="string">&#x27;world&#x27;</span>;</span><br><span class="line">bstring = <span class="string">&#x27;heloo&#x27;</span>; <span class="comment">// 不允许，只能是&#x27;hello&#x27;或者&#x27;world&#x27;其中之一</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> zimiana = <span class="string">&#x27;hello&#x27;</span>;  <span class="comment">// 如果将const改为let，第7行赋值则不会报错</span></span><br><span class="line"><span class="comment">// const zimiana: &#x27;hello&#x27; = &#x27;hello&#x27;; // 实际上ts做了默认的类型声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> zimianb: <span class="keyword">typeof</span> zimiana = <span class="string">&#x27;h&#x27;</span>; <span class="comment">// 不允许，必须是hello</span></span><br><span class="line"><span class="comment">// const zimianb: &#x27;hello&#x27; = &#x27;h&#x27;;  //意思同上，一定会报错</span></span><br></pre></td></tr></table></figure>

<p>使用不当的例子</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">iTakeFoo</span>(<span class="params">foo: <span class="string">&#x27;foo&#x27;</span></span>) </span>&#123;&#125;  <span class="comment">//‘foo’这个地方是类型</span></span><br><span class="line"><span class="keyword">const</span> test = &#123;</span><br><span class="line">  <span class="attr">someProp</span>: <span class="string">&#x27;foo&#x27;</span>,   <span class="comment">// &#x27;foo&#x27;这个地方是值</span></span><br><span class="line">&#125;;</span><br><span class="line">iTakeFoo(test.someProp); <span class="comment">//会报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决办法1：使用类型断言</span></span><br><span class="line"><span class="keyword">const</span> test = &#123;</span><br><span class="line">  <span class="attr">someProp</span>: <span class="string">&#x27;foo&#x27;</span> <span class="keyword">as</span> <span class="string">&#x27;foo&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决办法2: 使用类型注解</span></span><br><span class="line">type Test = &#123;</span><br><span class="line">  <span class="attr">someProp</span>: <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> test: Test = &#123;</span><br><span class="line">  <span class="attr">someProp</span>: <span class="string">&#x27;foo&#x27;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p> JS对象这种key:value格式与类型声明定义很像，也是经常被人误用的地方，下面的函数参数声明也有错误用例</p>
<h2 id="函数类型声明"><a href="#函数类型声明" class="headerlink" title="函数类型声明"></a>函数类型声明</h2><p>函数的定义方式有两种：函数声明和函数表达式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数声明（Function Declaration）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x： number, y: number</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 函数表达式（Function Expression）OR 匿名函数</span></span><br><span class="line">type MySum = <span class="function">(<span class="params">x: number, y: number</span>) =&gt;</span> number</span><br><span class="line"><span class="keyword">let</span> mySum: MySum = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 类型注释以后，输入多余的（或者少于要求的）参数，是不被TS允许的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数重载</span></span><br><span class="line">type Reverse = &#123;   </span><br><span class="line">  (a: number): number;</span><br><span class="line">  (a: string): string;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">x: number</span>): <span class="title">number</span></span>;  <span class="comment">// 输入number，返回number</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">x: string</span>): <span class="title">string</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">x: number | string</span>): <span class="title">number</span> | <span class="title">string</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Number</span>(x.toString().split(<span class="string">&#x27;&#x27;</span>).reverse().join(<span class="string">&#x27;&#x27;</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x.split(<span class="string">&#x27;&#x27;</span>).reverse().join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 优先从最前面的函数定义开始匹配，所以多个函数定义如果有包含关系，需要优先把精确的定义写在前面</span></span><br><span class="line"><span class="comment">// 用泛型抽象会更好</span></span><br><span class="line">type Reverse&lt;T&gt; = <span class="function">(<span class="params">x: T</span>) =&gt;</span> T;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用 ...rest 的方式获取函数中的剩余参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">push</span>(<span class="params">array: any[], ...items: any[]</span>) </span>&#123;</span><br><span class="line">    items.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">        array.push(item);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div style="color: red;">
类型注释以后，输入多余的（或者少于要求的）参数，是不允许的，可以用 ? 表示可选的参数，可选参数后面不允许再出现必需参数，添加了默认值的参数被识别为可选的参数
</div>

<p>错误使用例子</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数参数使用解构赋值，将索引key值为x的值赋给number变量，所以此处number并不是类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">&#123; x: number &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x); <span class="comment">// Error</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 正确写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">&#123; x &#125; : &#123;x : number&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line">f(&#123;<span class="attr">x</span>:<span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="交叉类型和联合类型"><a href="#交叉类型和联合类型" class="headerlink" title="交叉类型和联合类型"></a>交叉类型和联合类型</h2><h3 id="1、交叉类型-（-amp-相当于与）是多个类型的合并"><a href="#1、交叉类型-（-amp-相当于与）是多个类型的合并" class="headerlink" title="1、交叉类型 （&amp;相当于与）是多个类型的合并"></a>1、交叉类型 （&amp;相当于与）是多个类型的合并</h3><p>最好的例子就是Object.assign()</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface ObjectConstructor &#123;</span><br><span class="line">	<span class="comment">// 两个对象</span></span><br><span class="line">	assign&lt;T, U&gt;(target: T, <span class="attr">source</span>: U): T &amp; U;</span><br><span class="line">	<span class="comment">// 多个对象</span></span><br><span class="line">	assign&lt;T,U,V&gt;(target: T, <span class="attr">source1</span>: U, <span class="attr">source2</span>: V): T &amp; U &amp; V;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单的例子</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">interface IPerson &#123;</span><br><span class="line">    <span class="attr">name</span>: string,</span><br><span class="line">    <span class="attr">age</span>: number,</span><br><span class="line">&#125;</span><br><span class="line">interface IMan &#123;</span><br><span class="line">    <span class="attr">love</span>: string,</span><br><span class="line">    <span class="attr">age</span>: number,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> firstObj: IPerson &amp; IMan= &#123;  <span class="comment">// 必须两个同时满足</span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;jone&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">24</span>,</span><br><span class="line">    <span class="attr">love</span>: <span class="string">&#x27;jonk&#x27;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、联合类型-（｜相当于或）是多个类型中的一个或多个"><a href="#2、联合类型-（｜相当于或）是多个类型中的一个或多个" class="headerlink" title="2、联合类型 （｜相当于或）是多个类型中的一个或多个"></a>2、联合类型 （｜相当于或）是多个类型中的一个或多个</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> secondObj: IPerson | IMan = &#123; <span class="comment">// 只需满足其中一个类型，或者两个都满足</span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;frg&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">56</span>,</span><br><span class="line">    <span class="attr">love</span>: <span class="string">&#x27;frgrg&#x27;</span>,</span><br><span class="line">&#125; <span class="comment">// 如果一个对象具有联合类型，就只能访问他们之间共有的部分age</span></span><br><span class="line"><span class="built_in">console</span>.log(secondObj.age);</span><br><span class="line"><span class="built_in">console</span>.log(secondObj.name); <span class="comment">// 不允许</span></span><br></pre></td></tr></table></figure>

<p>解决上述问题</p>
<p>1、使用类型断言</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((secondObj <span class="keyword">as</span> IPerson).name) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log((secondObj <span class="keyword">as</span> IPerson).name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、使用类型保护，这种 param is SomeType 的形式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isIPerson</span>(<span class="params">obj: IPerson | IMan</span>): <span class="title">obj</span> <span class="title">is</span> <span class="title">IPerson</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (obj <span class="keyword">as</span> IPerson).name !== <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (isPerson(secondObj))&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(secondObj.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、使用typeof或者instanceof，typeof用于基本类型，instanceof用于引用类型</p>
<h2 id="type-amp-interface"><a href="#type-amp-interface" class="headerlink" title="type &amp; interface"></a>type &amp; interface</h2><p>type ：用来给一个新类型起别名</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">type Content = &#123;</span><br><span class="line">    <span class="attr">value</span> : number;</span><br><span class="line">    name: string;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 接口</span></span><br><span class="line">interface Content &#123;</span><br><span class="line">   <span class="attr">value</span>: number;</span><br><span class="line">   name: string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>interface：描述对象的形状（Shape）</p>
<p>面向对象的思想：将不同类之间的公共特性，提取出来定义为接口，供多个类各自实现。而我们平时使用大多数时候是用来定义JS对象的结构，比如定义state和props的类型；</p>
<p>接口可以继承接口，类可以实现接口；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">interface Alarm &#123;</span><br><span class="line">    alert(): <span class="keyword">void</span>;</span><br><span class="line">&#125;</span><br><span class="line">interface LightableAlarm <span class="keyword">extends</span> Alarm &#123;</span><br><span class="line">    lightOn(): <span class="keyword">void</span>;</span><br><span class="line">    lightOff(): <span class="keyword">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Door</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SecurityDoor</span> <span class="keyword">extends</span> <span class="title">Door</span> <span class="title">implements</span> <span class="title">Alarm</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">alert</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;SecurityDoor alert&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color="red">在TS中接口还可以继承类</font>：用class定义一个类的时候，同时也创建了同名的实例类型（不包括构造函数、静态属性和静态方法）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="attr">x</span>: number;</span><br><span class="line">    y: number;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">x: number, y: number</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">interface PointInstanceType &#123;</span><br><span class="line">    <span class="attr">x</span>: number;</span><br><span class="line">    y: number;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等价于 interface Point3d extends PointInstanceType</span></span><br><span class="line">interface Point3d <span class="keyword">extends</span> Point &#123;</span><br><span class="line">    <span class="attr">z</span>: number;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> point3d: Point3d = &#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">z</span>: <span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>type与interface的区别</p>
<table>
<thead>
<tr>
<th>type特点</th>
<th>interface特点</th>
</tr>
</thead>
<tbody><tr>
<td>要扩展已有type需要创建新type，不可以重名</td>
<td>同名interface可自动聚合，也可以和已有的同名class聚合，方便使用者自行扩展</td>
</tr>
<tr>
<td>不能被extends和implements</td>
<td>能被extends和implements</td>
</tr>
<tr>
<td>表达功能更强大，支持更复杂的类型操作，不局限于object/class/function</td>
<td>自身只能表示object/class/function的类型</td>
</tr>
</tbody></table>
<p><font color="red">TS声明合并：如果定义了两个相同名字的函数、接口或类，那么它们会合并成一个类型</font></p>
<h2 id="null和undefined类型"><a href="#null和undefined类型" class="headerlink" title="null和undefined类型"></a>null和undefined类型</h2><p>在tsconfig.json中设置”strictNullChecks”: false时（这也是默认值），null和undefined可以赋值给任何类型变量，反之不能，有一个特殊情况：</p>
<p>“strictNullChecks”: true时, 函数的可选参数类型会默认添加undefined类型</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fucnull</span>(<span class="params">x: number, y?:string</span>): <span class="title">number</span> </span>&#123;  <span class="comment">// y的类型是string | undefined</span></span><br><span class="line">    <span class="keyword">if</span> (y) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(fucnull(<span class="number">2</span>, <span class="literal">null</span>)); <span class="comment">// 不允许</span></span><br></pre></td></tr></table></figure>

<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>泛型使得类型可以编程，可以抽象出适用更加广泛的类型，可以与函数做类比，类型参数就像函数参数一样，可以有默认值，除此之外，还可以用extends对参数本身需要满足的条件进行限制</p>
<p>在定义一个function、type、interface、class时，名称后面加上&lt;&gt;表示接受类型参数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span>&lt;<span class="title">T</span>, <span class="title">K</span>&gt;(<span class="params">v1: T, v2: K</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [v2, v1]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时结果没有按照我们预期的被推断成 [K, T]，而是被推断成了 (K | T)[]，这是不符合要求的。这是因为 TypeScript 默认我们数组中的元素是可变的，所以它会「悲观的」推断我们可能会改变元素的顺序。鼠标放到运行函数时的swap上，我们可以看出类型被推断为</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span>&lt;<span class="title">Admin</span>, <span class="title">User</span>&gt;(<span class="params">v1: Admin, v2: User</span>): (<span class="params">Admin | User</span>)[]</span></span><br></pre></td></tr></table></figure>

<p>要改变这一行为，我们加上 as const 来声明它为常量，严格保证顺序，如下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span>&lt;<span class="title">T</span>, <span class="title">K</span>&gt;(<span class="params">v1: T, v2: K</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [v2, v1] <span class="keyword">as</span> <span class="keyword">const</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时鼠标hover类型被推断为</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span>&lt;<span class="title">Admin</span>, <span class="title">User</span>&gt;(<span class="params">v1: Admin, v2: User</span>): <span class="title">readonly</span> [<span class="title">User</span>, <span class="title">Admin</span>]</span></span><br></pre></td></tr></table></figure>

<h2 id="infer、extends关键字"><a href="#infer、extends关键字" class="headerlink" title="infer、extends关键字"></a>infer、extends关键字</h2><p><strong>extends</strong>: 既可当作一个动词来扩展已有类型（接口扩展），也可当作一个形容词来对类型进行条件限定（常常用在泛型中）</p>
<p>T extends U ? T : U    判断有条件类型</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Exclude(排除): 属于T不属于U的类型联合，不存在时为never</span></span><br><span class="line">type Exclude&lt;T, U&gt; = T <span class="keyword">extends</span> U ? never : T;</span><br><span class="line"><span class="comment">// Extract(抽取): 属于T且属于U的类型联合，不存在时为never</span></span><br><span class="line">type Extract&lt;T, U&gt; = T <span class="keyword">extends</span> U ? T : never;</span><br></pre></td></tr></table></figure>

<p>举个例子</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type A = Exclude&lt;<span class="string">&#x27;x&#x27;</span> | <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;x&#x27;</span> | <span class="string">&#x27;y&#x27;</span> | <span class="string">&#x27;z&#x27;</span>&gt;</span><br><span class="line"><span class="keyword">const</span> aValue: A = <span class="string">&#x27;a&#x27;</span>;  <span class="comment">// aValue的值只能是&#x27;a&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>infer</strong> 作用是让TypeScript自己推断，并将推断的结果存储到一个临时名字中，且只能用于extends语句中</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Obtain the return type of a function type</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">type ReturnType&lt;T <span class="keyword">extends</span> (...args: any) =&gt; any&gt; = T <span class="keyword">extends</span> (...args: any) =&gt; infer R ? R : any;  <span class="comment">// 给函数的返回值类型定义为R临时变量</span></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> &#123; <span class="attr">a</span>: <span class="number">3</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;; &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    a: number</span></span><br><span class="line"><span class="comment">    b: number</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">type FReturn = ReturnType&lt;<span class="keyword">typeof</span> f&gt;;</span><br></pre></td></tr></table></figure>

<p>【注】ReturnType可以获取函数返回值的类型。但要注意不要滥用这个工具类型，契约高于实现，这个工具类型是由实现反推契约，容易出错，另外ReturnType过多也会降低代码可读性</p>
<h2 id="索引签名-amp-索引类型"><a href="#索引签名-amp-索引类型" class="headerlink" title="索引签名 &amp; 索引类型"></a>索引签名 &amp; 索引类型</h2><h3 id="索引签名"><a href="#索引签名" class="headerlink" title="索引签名"></a>索引签名</h3><p>JavaScript 在一个对象类型的索引签名上会隐式调用 toString 方法，无论哪种类型本质上都是字符串的形式存储</p>
<p>而在TS中，索引签名的类型必须是string或者number, 且强制用户必须明确的写出 toString()方法（除了number类型以外）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法1:索引可以是string或者number</span></span><br><span class="line">interface Demo1&#123;</span><br><span class="line">    [key: string]: string;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//写法2:索引只能是number</span></span><br><span class="line">interface Demo2 &#123;</span><br><span class="line">    [key: number]: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> res: Demo1 = &#123;<span class="number">0</span> : <span class="string">&#x27;def&#x27;</span>&#125;;  <span class="comment">// JS隐式调用toString()方法</span></span><br><span class="line"><span class="keyword">const</span> res: Demo1 = &#123;<span class="attr">name</span> : <span class="string">&#x27;def&#x27;</span>&#125;; <span class="comment">// 或者 &#123;&#x27;name&#x27; : &#x27;def&#x27;&#125;</span></span><br><span class="line"><span class="keyword">const</span> res: Demo2 = &#123;<span class="attr">name</span> : <span class="string">&#x27;def&#x27;</span>&#125;; <span class="comment">// 或者 &#123;&#x27;name&#x27; : &#x27;def&#x27;&#125;  //不允许，报错</span></span><br></pre></td></tr></table></figure>

<p>当你声明一个索引签名时，所有明确的成员都必须符合索引签名</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface Bar &#123;</span><br><span class="line">    [key: string]: number;</span><br><span class="line">    x: number;</span><br><span class="line">    y: string; <span class="comment">// Error: y 属性必须为 number 类型</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="索引类型-keyof关键字"><a href="#索引类型-keyof关键字" class="headerlink" title="索引类型(keyof关键字)"></a>索引类型(keyof关键字)</h3><p>keyof  interfaceName | typeName: 获取接口或类型上的所有已知属性名的联合，跟Object.keys()有点像，但是keyof取类型的键, 【容易混淆的是TS中typeof，typeof后面跟的是值变量, keyof后面是类型变量，他们的返回值都是类型变量】</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">    <span class="attr">name</span>: string</span><br><span class="line">    <span class="attr">age</span>: number</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// type keys = &#x27;name&#x27; | &#x27;age&#x27;;</span></span><br><span class="line">type keys = keyof Person;</span><br></pre></td></tr></table></figure>
<h2 id="映射类型"><a href="#映射类型" class="headerlink" title="映射类型"></a>映射类型</h2><p>我们可能会遇到这么一些需求：</p>
<p>将一个现有类型的每个属性都变为可选的或者部分可选的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">interface PersonPartial &#123;</span><br><span class="line">  name?: string</span><br><span class="line">  age?: number</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">interface PersonPartial &#123;</span><br><span class="line">  <span class="attr">name</span> : string</span><br><span class="line">  age?: number</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将每个属性都变为只读的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface IPersonReadonly &#123;</span><br><span class="line">  readonly name: string</span><br><span class="line">  readonly age: number</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以利用ts提供的映射类型简写，通过这种映射的方式，我们可以将组件的参数进行更好的分类声明，同时也可以避免写多个？或者readonly这种声明方式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">type Readonly&lt;T&gt; = &#123;</span><br><span class="line">  readonly [P <span class="keyword">in</span> keyof T]: T[P]</span><br><span class="line">&#125;</span><br><span class="line">type Partial&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]?: T[P]</span><br><span class="line">&#125;</span><br><span class="line">type PersonReadonly = Readonly&lt;Person&gt;</span><br><span class="line">type PersonPartial = Partial&lt;Person&gt;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">type PersonPartial = &#123; <span class="comment">// 声明可选参数</span></span><br><span class="line">  <span class="attr">age</span>: number;</span><br><span class="line">&#125;</span><br><span class="line">type Person = &#123;  <span class="comment">//声明必填参数</span></span><br><span class="line">  <span class="attr">name</span>: string;</span><br><span class="line">&#125; &amp; Partial&lt;PersonPartial&gt;</span><br></pre></td></tr></table></figure>

<p>我们还可以自己定义更多的通用映射类型</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type Nullrable&lt;T&gt; = &#123;</span><br><span class="line">    [P <span class="keyword">in</span> keyof T]: T[P] | <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类型推论-amp-类型断言"><a href="#类型推论-amp-类型断言" class="headerlink" title="类型推论 &amp; 类型断言"></a>类型推论 &amp; 类型断言</h2><h3 id="类型推论"><a href="#类型推论" class="headerlink" title="类型推论"></a>类型推论</h3><p>如果变量在定义的时候没有赋值，不管之后有没有赋值，都会被推断成 any 类型而完全不被类型检查</p>
<h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><p>语法：值 as 类型  或者  &lt;类型&gt;值</p>
<p>类型断言的限制：【总的来说，若 A 兼容 B，那么 A 能够被断言为 B，B 也能被断言为 A】</p>
<ul>
<li>联合类型可以被断言为其中一个类型</li>
<li>父类可以被断言为子类，子类也可以被断言为父类</li>
<li>任何类型都可以被断言为 any，any 可以被断言为任何类型</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TypeScript 是结构类型系统，类型之间的对比只会比较它们最终的结构，而会忽略它们定义时的关系</span></span><br><span class="line">interface Animal &#123;</span><br><span class="line">    <span class="attr">name</span>: string;</span><br><span class="line">&#125;</span><br><span class="line">interface Cat &#123;</span><br><span class="line">    <span class="attr">name</span>: string;</span><br><span class="line">    run(): <span class="keyword">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">interface Animal &#123;</span><br><span class="line">    <span class="attr">name</span>: string;</span><br><span class="line">&#125;</span><br><span class="line">interface Cat <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">    run(): <span class="keyword">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【<font color="red"> 注意 </font>】类型断言不是类型转换，它不会真的影响到变量的类型。它只能够「欺骗」TypeScript 编译器，无法避免运行时的错误，反而滥用类型断言可能会导致运行时错误</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/09/01/TS%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%92%8C%E6%A6%82%E5%BF%B5/" data-id="clpuo0yvb0007otmu1fj528mp" class="article-share-link">
        Share
      </a>
      
    </footer>

  </div>

  

  

</article>
    
    <article id="post-初识react" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h2 itemprop="name">
  <a class="article-title" href="/2020/09/01/%E5%88%9D%E8%AF%86react/">初识React</a>
</h2>



    </header>
    

    
    <div class="article-meta">
      <a href="/2020/09/01/%E5%88%9D%E8%AF%86react/" class="article-date">
  <time datetime="2020-09-01T09:50:43.000Z" itemprop="datePublished">2020-09-01</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
      <h2 id="React生命周期函数"><a href="#React生命周期函数" class="headerlink" title="React生命周期函数"></a>React生命周期函数</h2><h3 id="挂载阶段只执行一次"><a href="#挂载阶段只执行一次" class="headerlink" title="挂载阶段只执行一次"></a><strong>挂载阶段只执行一次</strong></h3><p><code>constructor()</code>一般用来做初始化工作，例如初始化state</p>
<p><code>componentWillMount()</code>   已更名为  UNSAFE_componentWillMount()  如果在此函数中使用setState()并不会触发渲染，因为render()还没有执行，所以一般初始化state使用constructor()函数。</p>
<p><code>render()</code></p>
<p><code>componentDidMount()</code>一般用于请求异步加载的数据，添加事件监听</p>
<h3 id="更新阶段可多次执行，当props或state发生变化时"><a href="#更新阶段可多次执行，当props或state发生变化时" class="headerlink" title="更新阶段可多次执行，当props或state发生变化时"></a>更新阶段可多次执行，当props或state发生变化时</h3><p><code>componentWillReceiveProps(object:nextProps)</code> 已更名为  UNSAFE_componentWillReceiveProps()       已加载组件收到新的props时调用：如果父组件导致该组件重新渲染，这个方法也会被调用，即使props没有任何改变，如果您只想处理更改，请务必比较当前值和下一个值，你可以比较this.props和nextProps，并在这个方法中使用this.setState()执行状态转换。</p>
<p><code>shouldComponentUpdate(object:nextProps, object:nextState)</code>组件判断是否重新渲染时调用</p>
<p><code>componentWillUpdate(object:nextProps, object:nextState)</code>已更名为 UNSAFE_componentWillUpdate() 组件被重新渲染之前: 不要在这个函数中使用setState()</p>
<p><code>render()</code></p>
<p><code>componentDidUpdate(object:prevProps, object:prevState)</code>处理在生命周期中由于state或者props的变化触发新的请求</p>
<p><code>componentWillUnmount()</code>已经移除真实DOM时</p>
<p><strong>React旧版本生命周期图</strong>：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5287253-315eac1c26082f08.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="avatar"></p>
<p><strong>React新版本生命周期图</strong>：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5287253-19b835e6e7802233.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="avatar"></p>
<h3 id="变更的部分"><a href="#变更的部分" class="headerlink" title="变更的部分"></a>变更的部分</h3><p>新的react生命周期去掉了以下三个：</p>
<ul>
<li>componentWillMount</li>
<li>componentWillReceiveProps</li>
<li>componentWillUpdate</li>
</ul>
<p>同时为了弥补失去上面三个函数的不足又加了两个：</p>
<ul>
<li>static getDerivedStateFromProps</li>
<li>getSnapshotBeforeUpdate</li>
</ul>
<p>当然，这个更替是缓慢的，在整个16版本里都能无障碍的使用旧的三生命周期，但值得注意的是，旧的生命周期（unsafe）不能和新的生命周期同时出现在一个组件，否则会报错“你使用了一个不安全的生命周期”。</p>
<h3 id="为什么要改"><a href="#为什么要改" class="headerlink" title="为什么要改"></a>为什么要改</h3><p>旧的生命周期十分完整，基本可以捕捉到组件更新的每一个state/props/ref，没有什么从逻辑上的毛病。</p>
<p>但是架不住官方自己搞事情，react打算在17版本推出新的Async Rendering（也就是Fiber架构），提出一种可被打断的生命周期，而<strong>可以被打断的阶段正是实际dom挂载之前的虚拟dom构建阶段</strong>，也就是要被去掉的三个生命周期。</p>
<p>生命周期一旦被打断，下次恢复的时候又会再跑一次之前的生命周期，因此componentWillMount，componentWillReceiveProps， componentWillUpdate都不能保证只在挂载/拿到props/状态变化的时候刷新一次了，所以这三个方法被标记为不安全。</p>
<h3 id="两个新的生命周期"><a href="#两个新的生命周期" class="headerlink" title="两个新的生命周期"></a>两个新的生命周期</h3><ul>
<li><strong>static getDerivedStateFromProps(nextProps, prevState)</strong></li>
</ul>
<p><strong>触发时间</strong>：组件每次被渲染时（包括组件构建之后），每次获取新的props或state之后。</p>
<p><strong>返回值</strong>：每次接收新的props之后都会返回一个对象作为新的state,返回null则说明不需要更新state</p>
<p><strong>作用</strong>：配合componentDidUpdate,可以覆盖componentWillReceiveProps的所有用法</p>
<ul>
<li><strong>getSnapshotBeforeUpdate(prevProps, prevState)</strong></li>
</ul>
<p><strong>触发时间</strong>: update发生的时候，在render之后，在组件dom渲染挂载之前。</p>
<p><strong>返回值</strong>：作为componentDidUpdate(prevProps, prevState, snapshot)的第三个参数。</p>
<p><strong>作用</strong>：配合componentDidUpdate, 可以覆盖componentWillUpdate的所有用法。</p>
<h2 id="React组件区别"><a href="#React组件区别" class="headerlink" title="React组件区别"></a>React组件区别</h2><p>1、组件的名称必须以大写字母开头</p>
<p>2、组件的返回值只能有一个根元素</p>
<p>3、函数组件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function Welcome (props) &#123;</span><br><span class="line">  return &lt;h1&gt;Welcome &#123; props.name &#125;&lt;/h1&gt;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(&lt;Welcome name=&#x27;react&#x27; /&gt;, document.getElementById(&#x27;root&#x27;));</span><br></pre></td></tr></table></figure>

<p>4、类组件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Welcome extends React.Component(props) &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">  	return (</span><br><span class="line">      &lt;h1&gt;Welcome &#123; this.props.name &#125;&lt;/h1&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(&lt;Welcome name=&#x27;react&#x27; /&gt;, document.getElementById(&#x27;root&#x27;));</span><br></pre></td></tr></table></figure>

<p>5、所有react组件必须都是<strong>纯函数</strong>(函数内部不会修改输入参数，输入相同，输出必然相同)，无论是哪种组件都不能修改它自己的props</p>
<p>6、组件的属性和状态改变都会更新视图</p>
<p>7、函数组件和类组件的区别</p>
<table>
<thead>
<tr>
<th>区别</th>
<th>函数组件</th>
<th>类组件</th>
</tr>
</thead>
<tbody><tr>
<td>是否有this</td>
<td>没有</td>
<td>有</td>
</tr>
<tr>
<td>是否有生命周期</td>
<td>没有</td>
<td>有</td>
</tr>
<tr>
<td>是否有状态state</td>
<td>没有</td>
<td>有</td>
</tr>
</tbody></table>
<p>函数组件的性能要比类组件的性能高，因为类组件使用的时候要实例化，函数组件直接执行函数取返回结果即可。</p>
<h2 id="render-何时被触发"><a href="#render-何时被触发" class="headerlink" title="render()何时被触发"></a>render()何时被触发</h2><ol>
<li>一个组件必须通过setState()去改变this.state的状态，才能引发重新渲染，或者是组件的props状态改变也可引发重新渲染；</li>
<li>父组件重新渲染也会导致子组件的重新渲染，有时候为了避免不必要的渲染，我们需要在shouldComponentUpdate()中将新老state和props做对比，如果没有发生改变就返回false，可以阻止component渲染；</li>
<li>当然有时候这种简单的判断，显得有些多余和样板化，于是react就提供了PureComponent来自动对比；</li>
<li><strong>但是PureComponent自动添加的shouldComponentUpate函数，只是对props和state进行浅比较(shadow comparison)，当props或者state本身是嵌套对象或数组时，浅比较并不能得到预期的结果，这很可能会导致实际的props和state发生了变化，<em>但组件却没有更新的问题</em></strong>。</li>
<li>浅比较都做了什么？</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (this._compositeType === CompositeTypes.PureClass) &#123;</span><br><span class="line">shouldUpdate = !shallowEqual(prevProps, nextProps)</span><br><span class="line">|| !shallowEqual(inst.state, nextState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>比较 <code>Object.keys(state | props)</code> 的长度是否一致</li>
<li>每一个 <code>key</code>是否两者都有</li>
<li>相同的<code>key</code>是否是同一个引用</li>
</ul>
<h2 id="state更新"><a href="#state更新" class="headerlink" title="state更新"></a><strong>state</strong>更新</h2><ol>
<li>异步更新：由 <strong>React</strong> 控制的事件处理过程 <strong>setState</strong> 不会同步更新 <strong>this.state</strong>！<ul>
<li>在大部分的使用情况下，我们都是使用了 React 库中的表单组件，例如 select、input、button 等等，它们都是 React 库中人造的组件与事件，是处于 React 库的控制之下，比如组件原色 onClick 都是经过 React 包装。在这个情况下，setState 就会以异步的方式执行。也就意味着大部分函数中都会异步更新。</li>
</ul>
</li>
<li>同步更新：在 <strong>React</strong> 控制之外的情况， <strong>setState</strong> 会同步更新 <strong>this.state</strong>！<ul>
<li>通过addEventListener直接添加的事件处理函数，或者setTimeout/setInterval产生的异步调用可以同步更新。</li>
</ul>
</li>
</ol>
<h2 id="使用setState注意"><a href="#使用setState注意" class="headerlink" title="使用setState注意"></a>使用<strong>setState</strong>注意</h2><ol>
<li>不要直接修改state，通过setState()方法修改才能触发重复渲染</li>
<li>setState()的参数不是一个对象，而是一个函数时，这个函数默认两个参数分别是state和props，这个函数应该返回一个对象表示对state的更改</li>
<li>每次setState产生新的state会依次被存入一个队列，然后会根据isBathingUpdates变量判断是直接更新this.state，还是放进dirtyComponent里回头再说，isBathingUpdates默认是false, 也就表示setState会同步更新this.state。但是，当React在调用事件处理函数之前就会调batchedUpdates，这个函数会把isBatchingUpdates修改为true，造成的后果就是由React控制的事件处理过程setState不会同步更新this.state。</li>
<li>函数用到更新的state变量时，要将函数写到setState()函数的第二个参数（接受一个回调函数）</li>
<li>事实上，setState 方法与包含在其中的执行是一个很复杂的过程，从 React 最初的版本到现在，也有无数次的修改。它的工作除了要更动 this.state 之外，还要负责触发重新渲染，这里面要经过 React 核心 diff 算法，最终才能决定是否要进行重渲染，以及如何渲染。而且为了批次与效能的理由，多个 setState 呼叫有可能在执行过程中还需要被合并，所以它被设计以延时的来进行执行是相当合理的。 </li>
<li>React官方建议把state当作是不可变对象，state中包含的所有状态都应该是不可变的对象，当state中的某个状态发生变化时，我们应该重新创建这个状态对象，而不是直接修改原来的状态。</li>
</ol>
<p>​       <strong>值类型变量</strong>：number,boolean,string,null,undefined本身就是不可变的，修改时直接赋值就可以了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">this.setState(&#123;</span><br><span class="line">   num: 1,</span><br><span class="line">   string: &#x27;hello&#x27;,</span><br><span class="line">   ready: true</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure>

<p>​    <strong>数组类型变量</strong>：若要从原来的数组中获取部分作为新的state值，应使用slice、concat、filter这种不会修改            原数组的函数，不应该使用push、pop、 shift、 unshift、 splice在原来的数组上进行操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let students = this.state.students;</span><br><span class="line">   this.setState(&#123;</span><br><span class="line">     students: students.concat([&#x27;xiaohua&#x27;])</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">   //或者ES6语法</span><br><span class="line">   this.setState(preState =&gt; (&#123;</span><br><span class="line">     students: [ ...preState.students, &#x27;xiaohua&#x27;]</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure>

<p>​    <strong>普通对象</strong>：对象也是可变类型，修改对象类型的状态时，应该保证不会修改原来的状态，可以使用ES6的Object.assign()方法，或者对象扩展的语法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//Object.assign方法</span><br><span class="line">this.setState(preState =&gt; (&#123;</span><br><span class="line">  school: Object.assign(&#123;&#125;, preState.school, &#123;classNum: 10&#125;)</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line">//对象扩展语法</span><br><span class="line">let school = this.state.school;</span><br><span class="line">this.setState(&#123;</span><br><span class="line">  school: &#123; ...school, classNum: 10 &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h2 id="PureComponent"><a href="#PureComponent" class="headerlink" title="PureComponent"></a>PureComponent</h2><p>React15.3中新增的类，在普通的component中，我们为了减少不必要的渲染render，提高性能，会在shouldComponentUpdate()中判断组件的props和state是否发生了改变，如果没有变化就返回false不会触发render方法，省去了Virtual DOM 的生成和对比过程。</p>
<h2 id="React路由"><a href="#React路由" class="headerlink" title="React路由"></a>React路由</h2><p>目前官网同时维护2.x(react-router)和4.x(react-router-dom)版本的路由，两个版本用法不同，不能兼容，现在我们使用npm安装react-router基本都是4.x版本的。</p>
<h3 id="属性exact和strict"><a href="#属性exact和strict" class="headerlink" title="属性exact和strict"></a>属性exact和strict</h3><p>我们在使用route的时候匹配路径的规则是模糊的，类似正则匹配的贪婪匹配，为了避免如下图所示匹配失效的情况，我们应该正确使用exact和strict属性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ReactDom.render(</span><br><span class="line">    &lt;HashRouter&gt;</span><br><span class="line">        &lt;Switch&gt;</span><br><span class="line">            &lt;Route path = &#x27;/&#x27; component=&#123;App&#125; /&gt;</span><br><span class="line">            &lt;Route path = &#x27;/PageA&#x27; component=&#123;PageA&#125; /&gt;</span><br><span class="line">            &lt;Route path = &#x27;/PageB&#x27; component=&#123;PageB&#125; /&gt;</span><br><span class="line">        &lt;/Switch&gt;</span><br><span class="line">    &lt;/HashRouter&gt;, document.getElementById(&#x27;root&#x27;)</span><br><span class="line"> );</span><br></pre></td></tr></table></figure>

<p>这种情况下访问<a target="_blank" rel="noopener" href="http://localhost:3000/#/%E5%92%8Chttp://localhost:3000/#/PageA%E9%83%BD%E4%BC%9A%E6%B8%B2%E6%9F%93App%E7%BB%84%E4%BB%B6%EF%BC%8C%E5%8D%B3%E4%BD%BFhash%E5%80%BC%E5%B7%B2%E7%BB%8F%E6%94%B9%E5%8F%98%E3%80%82">http://localhost:3000/#/和http://localhost:3000/#/PageA都会渲染App组件，即使hash值已经改变。</a></p>
<p><strong>exact属性</strong>：默认不写为false，当它为true时，路径中的hash值必须和path完全一致才渲染对应的组件（如果strict属性为false，则末尾是否包含反斜杠结尾不影响匹配结果）</p>
<p><strong>strict属性</strong>：默认不写为false，如果strict属性为true，并且path中不包含反斜杠结尾，那么它也不能匹配包含反斜杠结尾的路径。(一般配合exact同时使用)</p>
<p>两个属性同时使用是最精确的匹配</p>
<table>
<thead>
<tr>
<th align="center">exact</th>
<th>strict</th>
<th>path</th>
<th>Location.pathname</th>
<th>Matches?</th>
</tr>
</thead>
<tbody><tr>
<td align="center">True</td>
<td>False</td>
<td>/one</td>
<td>/one/</td>
<td>True</td>
</tr>
<tr>
<td align="center">True</td>
<td>True</td>
<td>/one</td>
<td>/one/</td>
<td>False</td>
</tr>
</tbody></table>
<p><strong>注意</strong>：通过hash路由进行页面跳转导航时，只会加载相应的组件内容，运行组件的生命周期函数，不会运行模块的代码，也就是组件之外的属于模块级别的代码，这些属于模块的代码只在第一次加载该页面时运行。</p>
<p>失败场景：组件中某个样式的展示是根据声明在模块中的变量来决定，此时通过path的改变跳转到其他组件，然后再通过路由跳转回原来的页面，由于第二次跳转到这个页面时不会在运行模块级别的代码，就可能会导致组件中某些样式的展示与第一次不同。</p>
<p><strong>react-router-dom使用注意：</strong></p>
<p>如果想在某个路由下新建子路由，那么这个路由匹配时不能使用exact，否则会找不到页面</p>
<p><Route/>放哪组件就显示在哪</p>
<p>使用<BrowserRouter>需要服务端做配置，将任何请求都转发到index.html中的根路由上</p>
<p><HashRouter>不需要做额外处理，因为发送到服务器的请求永远都是#前面的内容，都是同一个页面，#后面的值用来做前端页面路由，对浏览器的兼容性更好，支持老版本浏览器。</p>
<Link>里面一般用props.match.url

<p><Route>里面一般使用props.match.path</p>
<p><code>HashRouter</code> 使用 URL 中的 hash（#）部分去创建形如 <code>example.com/#/some/path</code> 的路由，hash值后面的内容都不会发送到服务端，hash后面的内容纯粹是前端页面路由。</p>
<p><code>BrowserRouter</code> 是使用浏览器中的<a target="_blank" rel="noopener" href="https://www.renfei.org/blog/html5-introduction-3-history-api.html">HTML5的History API</a>处理 URL的，每次都会创建一个像example.com/list/123`这样真实的 URL 发送给服务端。</p>
<p><strong>为什么BrowserRouter需要服务端配置？</strong></p>
<p>因为真实URL其实是指向服务器资源，当通过真实URL访问网站的时候，第一次访问的是网站的域名，这个时候可以正常加载我们的网站js等文件，而用户手动刷新网页时，由于路径是指向服务器的真实路径，服务器端没有做相应的路由配置，就会导致资源不存在，用户访问的资源不存在，返回给用户的是404错误。<br>通过hashHistory来生成的URL就不会出现这样的问题，因为他不是指向真实的路由。</p>
<p><strong>服务端配置原理？</strong></p>
<p>其本质的原理就是利用服务端将任何请求都指向<code>index.html</code>，而在React应用中index.html又刚好通过React-Router配置了相应的路由，我们让服务器返回index.html，后面就交给前端路由来实现无刷新加载对应页面。</p>
<h2 id="React之ref"><a href="#React之ref" class="headerlink" title="React之ref"></a>React之ref</h2><p>在典型的React数据流中，props是唯一的父组件与子组件间的通讯方式，通过给子组件传递不同的参数，也可以达到组件复用的优势。但是在某些情况下，被更改的元素可能是一个react组件的实例，或者是一个DOM元素，这个时候就要用ref。</p>
<h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p>一般在构造函数中React.createRef()创建的ref，当组件被创建时分配给实例变量，这样render中的DOM节点就能够被引用，但是不要过度使用ref</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class MyComponent extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.myRef = React.createRef();</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;div ref=&#123;this.myRef&#125; /&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="访问"><a href="#访问" class="headerlink" title="访问"></a><strong>访问</strong></h4><p>当一个ref通过render放入一个元素中，要想在其它函数中获得该元素对象的引用，可以通过ref的current属性得到。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const node = this.myRef.current;</span><br></pre></td></tr></table></figure>

<h4 id="ref的值根据节点类型的不同而不同"><a href="#ref的值根据节点类型的不同而不同" class="headerlink" title="ref的值根据节点类型的不同而不同"></a><strong>ref的值根据节点类型的不同而不同</strong></h4><ol>
<li>当ref属性用于html元素，在构造器中通过React.createRef()函数创建的ref，接收底层DOM元素作为它的current属性</li>
<li>当ref属性用于传统的类组件，ref对象接收挂载好的组件实例作为它的current属性</li>
<li>ref属性不能用于函数式组件上，因为他们并没有实例，但是我们可以在函数式组件中使用ref属性。</li>
</ol>
<h4 id="ref使用注意"><a href="#ref使用注意" class="headerlink" title="ref使用注意"></a>ref使用注意</h4><p>一般什么时候使用？</p>
<ul>
<li>管理焦点、文本选择、媒体回放</li>
<li>触发必要动画；</li>
<li>整合第三方DOM库</li>
</ul>
<p>避免对任何可以声明式解决的问题使用Refs；比如相对于暴露一个对话框组件的open()、close()方法，请使用isOpen prop！不要过度使用！</p>
<h4 id="向父组件暴露子组件的Dom元素的引用使用ref-forwarding"><a href="#向父组件暴露子组件的Dom元素的引用使用ref-forwarding" class="headerlink" title="向父组件暴露子组件的Dom元素的引用使用ref forwarding"></a>向父组件暴露子组件的Dom元素的引用使用<a target="_blank" rel="noopener" href="https://reactjs.org/docs/forwarding-refs.html">ref forwarding</a></h4><p>在很罕见的情况下，我们需要从父组件访问到子组件的DOM节点。通常来说我们不建议这样做，因为这样破坏了组件的封装性，但是在某些情况下对于类似：触发聚焦、改变子元素DOM节点的大小、位置等情况非常有用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const FancyButton = React.forwardRef((props, ref) =&gt; (</span><br><span class="line">  &lt;button ref=&#123;ref&#125; className=&quot;FancyButton&quot;&gt;</span><br><span class="line">    &#123;props.children&#125;</span><br><span class="line">  &lt;/button&gt;</span><br><span class="line">));</span><br><span class="line"></span><br><span class="line">// You can now get a ref directly to the DOM button:</span><br><span class="line">const ref = React.createRef();</span><br><span class="line">&lt;FancyButton ref=&#123;ref&#125;&gt;Click me!&lt;/FancyButton&gt;;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：传统方式定义的类组件以及函数组件是不能够接收参数ref的，只有通过React.forwardRef()函数创建的组件才可以接受ref参数。</p>
<h4 id="回调ref"><a href="#回调ref" class="headerlink" title="回调ref"></a>回调ref</h4><p>React将会在组件挂载时使用DOM元素调用ref回调，在组件卸载时使用null调用ref回调。ref回调都会在componentDidMount或者componentDidUpdate生命周期钩子之前被调用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class CustomTextInput extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.textInput = null;</span><br><span class="line">    this.setTextInputRef = element =&gt; &#123;</span><br><span class="line">        this.textInput = element;</span><br><span class="line">    &#125;;</span><br><span class="line">    this.focusTextInput = () =&gt; &#123;</span><br><span class="line">      // 通过原生DOM API聚焦文本</span><br><span class="line">      if (this.textInput) this.textInput.focus();</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    // 在挂载时自动聚焦</span><br><span class="line">    this.focusTextInput();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    // 使用&#x27;ref&#x27;回调去在一个实例域中储存文本输入DOM元素的引用(比如, this.textInput).</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=&quot;text&quot;</span><br><span class="line">          ref=&#123;this.setTextInputRef&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=&quot;button&quot;</span><br><span class="line">          value=&quot;Focus the text input&quot;</span><br><span class="line">          onClick=&#123;this.focusTextInput&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/09/01/%E5%88%9D%E8%AF%86react/" data-id="clpuo0yvf000cotmu1e4f6jdy" class="article-share-link">
        Share
      </a>
      
    </footer>

  </div>

  

  

</article>
    
    <article id="post-了解Window对象" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h2 itemprop="name">
  <a class="article-title" href="/2020/05/06/%E4%BA%86%E8%A7%A3Window%E5%AF%B9%E8%B1%A1/">了解Window对象</a>
</h2>



    </header>
    

    
    <div class="article-meta">
      <a href="/2020/05/06/%E4%BA%86%E8%A7%A3Window%E5%AF%B9%E8%B1%A1/" class="article-date">
  <time datetime="2020-05-06T09:50:43.000Z" itemprop="datePublished">2020-05-06</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
      <h2 id="Window对象"><a href="#Window对象" class="headerlink" title="Window对象"></a>Window对象</h2><p>以下都是window对象的一部分</p>
<h3 id="Document对象（DOM）"><a href="#Document对象（DOM）" class="headerlink" title="Document对象（DOM）"></a>Document对象（DOM）</h3><p><strong>属性：</strong></p>
<p>document.body : 获取当前文档的body标签元素</p>
<p>document.cookie : 设置或返回与当前文档有关的所有cookie</p>
<p>document.documentURI 设置或返回文档的URI</p>
<p>document.domain 返回文档的域名</p>
<p><strong>方法：</strong></p>
<p>document.createAttribute(‘attributeName’) : 创建一个属性节点</p>
<p>document.createElement(‘elementName’) : 创建元素节点</p>
<p>document.createTextNode(‘textContent’) 创建文本节点</p>
<p>document.querySelector(‘CSS selector’) 返回匹配CSS选择器的第一个节点</p>
<p>document.querySelectorAll(‘CSS selector’) 返回所有匹配的节点，返回NodeList对象</p>
<h3 id="Location对象"><a href="#Location对象" class="headerlink" title="Location对象"></a>Location对象</h3><p>是window对象的一个部分，一般通过window.location属性访问</p>
<p>假设当前页面的URL是：<a target="_blank" rel="noopener" href="http://example.com:1234/test/test.html#part2?name=John">http://example.com:1234/test/test.html#part2?name=John</a></p>
<p>通过下面属性可以设置或返回我们想要的URL部分字段，它们都是可读写的字符串类型</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
<th>返回值</th>
</tr>
</thead>
<tbody><tr>
<td>host</td>
<td>当前URL的主机名和端口号</td>
<td>‘example.com:1234’</td>
</tr>
<tr>
<td>hostname</td>
<td>当前URL的主机名</td>
<td>‘example.com’</td>
</tr>
<tr>
<td>href</td>
<td>当前显示的文档的完整 URL</td>
<td>‘<a target="_blank" rel="noopener" href="http://example.com:1234/test/test.html#part2?name=John&#39;">http://example.com:1234/test/test.html#part2?name=John&#39;</a></td>
</tr>
<tr>
<td>pathname</td>
<td>当前URL的路径部分</td>
<td>‘/test/test.html’</td>
</tr>
<tr>
<td>port</td>
<td>当前 URL 的端口部分</td>
<td>‘1234’</td>
</tr>
<tr>
<td>protocol</td>
<td>当前 URL 的协议</td>
<td>‘http:’</td>
</tr>
<tr>
<td>search</td>
<td>当前 URL 的查询部分（问号 ? 之后的部分）</td>
<td>‘?name=John’</td>
</tr>
<tr>
<td>hash</td>
<td>URL 的锚部分（从 # 号开始的部分）</td>
<td>‘#part2?name=John’</td>
</tr>
</tbody></table>
<h3 id="History对象"><a href="#History对象" class="headerlink" title="History对象"></a>History对象</h3><p>window.history是用来保存用户在一个会话期间的网站访问记录，并提供相应的方法进行追溯。其成员如下：</p>
<p><strong>属性</strong>：length、state</p>
<p><strong>方法</strong>：back() 、forward() 、go(num) 、pushState(stateData,title,url)、replaceState(stateData,title,url)</p>
<p><strong>事件</strong>：onpopstate、onhashchange</p>
<p><strong>点击页面前进或后退按钮都会触发popstate事件，以下三个方法也都可以触发，事件对应的回调函数参数event可以访问state信息</strong></p>
<p><code>history.back()</code> //回退到上一个访问记录</p>
<p><code>history.forward()</code> //前进到下一个访问记录</p>
<p><code>history.go(num)</code> //num为正数是前进，负数是后退，history.go(0)相当于刷新当前页面</p>
<p><strong>HTML5规范为history对象新添加了两个方法，用来在浏览历史中添加和修改记录，不能跨域，不会造成页面刷新，不会触发onpopstate事件</strong></p>
<p><code>history.pushState() </code>//在history栈中添加一个新的网址，当前location.href变为新网址</p>
<p><code>history.replaceState()</code> //修改当前的访问记录网址</p>
<p><strong>pushState()通过back()可以将网址修改为执行pushState操作之前的网址，而replaceState()则不能</strong>。</p>
<p><strong>直接修改location.href是会引起页面刷新的，并且原来会话的history栈中当前网址往前的记录都会删除</strong>。</p>
<p>以上两个方法的主要应用是配合AJAX，使得页面可以恢复在AJAX请求之前的状态，如果我们在页面中执行一个ajax操作，当操作成功（如更新页面的局部内容）后，我们通过代码调用pushState方法，设置一个新的url，这样看上去就像发起了一个全新的请求，实际上只是个ajax操作。这时回退按钮也能用了，可以通过编写代码，来响应这个回退按钮触发的popstate事件，在事件中让界面恢复到ajax请求之前的界面。</p>
<p>也就是为AJAX动态请求的页面提供了与之对应的url记录，从而避免了前进或后退按钮导致页面崩溃或不存在</p>
<h2 id="Navigator对象"><a href="#Navigator对象" class="headerlink" title="Navigator对象"></a>Navigator对象</h2><p>navigator对象包含浏览器相关的信息</p>
<table>
<thead>
<tr>
<th>appCodeName</th>
<th>返回浏览器的代码名</th>
</tr>
</thead>
<tbody><tr>
<td>appName</td>
<td>返回浏览器的名称</td>
</tr>
<tr>
<td>appVersion</td>
<td>返回浏览器的平台和版本信息</td>
</tr>
<tr>
<td>cookieEnabled</td>
<td>返回指明浏览器中是否启用 cookie 的布尔值</td>
</tr>
<tr>
<td>platform</td>
<td>返回运行浏览器的操作系统平台</td>
</tr>
<tr>
<td>userAgent</td>
<td>返回由客户机发送服务器的user-agent 头部的值</td>
</tr>
</tbody></table>
<h2 id="Screen对象"><a href="#Screen对象" class="headerlink" title="Screen对象"></a>Screen对象</h2><p>screen对象包含有关客户端显示屏的信息</p>
<table>
<thead>
<tr>
<th>availHeight</th>
<th>返回屏幕的高度（不包括Windows下面的任务栏）</th>
</tr>
</thead>
<tbody><tr>
<td>availWidth</td>
<td>返回屏幕的宽度（不包括Windows下面的任务栏）</td>
</tr>
<tr>
<td>colorDepth</td>
<td>返回目标设备或缓冲器上的调色板的比特深度</td>
</tr>
<tr>
<td>pixelDepth</td>
<td>返回屏幕的颜色分辨率（每象素的位数）</td>
</tr>
<tr>
<td>height</td>
<td>返回屏幕总高度</td>
</tr>
<tr>
<td>width</td>
<td>返回屏幕总宽度</td>
</tr>
</tbody></table>
<h2 id="存储对象"><a href="#存储对象" class="headerlink" title="存储对象"></a>存储对象</h2><p>localStorage ： key-value键值对，没有过期时间</p>
<p>sessionStorage ： key-value键值对，关闭当前浏览器窗口失效</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/05/06/%E4%BA%86%E8%A7%A3Window%E5%AF%B9%E8%B1%A1/" data-id="clpuo0yve000botmu8ams9lss" class="article-share-link">
        Share
      </a>
      
    </footer>

  </div>

  

  

</article>
    
    <article id="post-前端性能指标" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h2 itemprop="name">
  <a class="article-title" href="/2020/04/26/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/">前端常用性能指标</a>
</h2>



    </header>
    

    
    <div class="article-meta">
      <a href="/2020/04/26/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/" class="article-date">
  <time datetime="2020-04-26T09:50:43.000Z" itemprop="datePublished">2020-04-26</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
        
      
      
      <h2 id="常用指标"><a href="#常用指标" class="headerlink" title="常用指标"></a>常用指标</h2><h3 id="1、首字节时间（TTFB）"><a href="#1、首字节时间（TTFB）" class="headerlink" title="1、首字节时间（TTFB）"></a>1、首字节时间（TTFB）</h3><p>终端用户首次请求 web 服务器和 web 服务器响应到终端用户之间这段时间</p>
<h3 id="2、白屏时间"><a href="#2、白屏时间" class="headerlink" title="2、白屏时间"></a>2、白屏时间</h3><p>白屏时间 = firstPaint - pageStartTime;</p>
<p>我们通常认为浏览器开始渲染 body 标签或者解析完 head 标签的时刻就是页面白屏结束的时间点</p>
<h3 id="3、DOM-Ready时间-DOMContentLoaded"><a href="#3、DOM-Ready时间-DOMContentLoaded" class="headerlink" title="3、DOM Ready时间 (DOMContentLoaded)"></a>3、DOM Ready时间 (DOMContentLoaded)</h3><p>当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完全加载</p>
<h3 id="4、首屏时间"><a href="#4、首屏时间" class="headerlink" title="4、首屏时间"></a>4、首屏时间</h3><p>定义：用户看到第一屏页面的时间</p>
<p>获取：不断获取屏幕截图，当截图不再变化时，可以视为首屏时间。</p>
<p>一般影响首屏的主要因素是图片的加载，通过页面加载完后判断图片是否在首屏内，找出加载最慢的一张即可视为首屏时间。</p>
<p>优化建议：</p>
<ul>
<li>页面首屏的显示尽量不要依赖于js代码，js尽量放到domReady后执行或加载</li>
<li>首屏外的图片延迟加载</li>
<li>首屏结构尽量简单，首屏外的css可延迟加载</li>
</ul>
<h3 id="5、页面完全加载时间（onload）"><a href="#5、页面完全加载时间（onload）" class="headerlink" title="5、页面完全加载时间（onload）"></a>5、页面完全加载时间（onload）</h3><p>定义：原始文档和所有引用的内容已经加载完成，用户最明显的感觉就是浏览器上loading状态结束。</p>
<p>获取： window.onload事件触发的时间</p>
<p>优化建议：</p>
<ul>
<li>减少资源的请求数和文件大小</li>
<li>将非初始化脚本放到onLoad之后执行</li>
<li>无需同步的脚本异步加载</li>
</ul>
<h3 id="6、外部资源加载时间"><a href="#6、外部资源加载时间" class="headerlink" title="6、外部资源加载时间"></a>6、外部资源加载时间</h3><p>等于 页面完全加载时间 减去DOM ready时间</p>
<h2 id="常用统计口径TP50、TP90"><a href="#常用统计口径TP50、TP90" class="headerlink" title="常用统计口径TP50、TP90"></a>常用统计口径TP50、TP90</h2><p>TP50指的是中位数，TP90指的是90分位数</p>
<h2 id="性能优化的方式"><a href="#性能优化的方式" class="headerlink" title="性能优化的方式"></a>性能优化的方式</h2><p>影响前端性能主要有这几个方面：网络请求（http请求）、css优化、页面渲染、js执行、缓存、图片等等</p>
<ol>
<li>减少 http 请求次数 合并css、js代码、静态资源图片，可以使用雪碧图</li>
<li>减少 http 请求的大小 减少没必要的图片、js、css；使用gzip压缩资源文件大小；对代码进行压缩、移除注释；压缩静态资源图片</li>
<li>将 css 和 js 放到外部文件中，避免直接使用 style 和 script 标签 在 HTML 文件上引用外部资源可以有效利用浏览器的静态资源缓存</li>
<li>避免空的 href 和 src。当<link>标签的href属性为空，或&lt;script&gt;、&lt;img&gt;、&lt;iframe&gt;标签的src属性为空时，浏览器在渲染过程中仍会将href属性或者src属性中的空内容进行加载，直至加载失败，这样就阻塞了页面中其他资源的下载进程，而且最终加载到的内容是无效的</li>
<li>合理设置浏览器缓存策略（强缓存、协商缓存），通过设置请求头参数。<ol start="6">
<li>强缓存：避免频繁向服务器端发送请求，在页面中的Cache-Control 或 Expires头部有效时，浏览器将直接从缓存中读取内容，不再向服务器端发送请求；</li>
<li>协商缓存：对于未修改的文件，静态资源服务器会向浏览器端返回304，让浏览器从缓存中读取文件，减少Web资源下载的带宽消耗并降低服务器负载</li>
</ol>
</li>
<li>减少页面重定向次数</li>
<li>合理使用CDN来存储文件</li>
<li>对于页面中加载时间过长的 CSS 或 JavaScript 文件，需要进行合理拆分或延后加载，保证关键渲染路径的资源能快速加载完成</li>
<li>异步加载JavaScript资源</li>
<li>尽可能的减少DOM的数量和深度，标签越多，层级越深，解析消耗的时间越久</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/26/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/" data-id="clpuo0yvh000fotmu2tq1bs0i" class="article-share-link">
        Share
      </a>
      
    </footer>

  </div>

  

  

</article>
    
  </article>
  

  
  <nav class="page-nav">
    <a class="extend prev" rel="prev" href="/">Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">Next</a>
  </nav>
  
</section>
</div>
    <footer class="footer">
  <div class="outer">
    <div class="float-right">
      <ul class="list-inline">
  
  <li><i class="fe fe-bar-chart"></i> <span id="busuanzi_value_site_pv"></span></li>
  
  <li><i class="fe fe-smile-alt"></i> <span id="busuanzi_value_site_uv"></span></li>
  
</ul>
    </div>
    <ul class="list-inline">
      <li>Hexo &copy; 2023</li>
      
        <li>quhandong</li>
      
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <!-- <li>theme  <a target="_blank" rel="noopener" href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li> -->
    </ul>
  </div>
</footer>
  </main>
  <aside class="sidebar">
    <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/hexo.svg" alt="Hexo"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">Home</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">Archives</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="https://www.douyin.com/user/MS4wLjABAAAA4EevfdHrS1s-urfPJWWJEs-_c_qLu19jtr-eYdpBNBk?enter_from=main_page&enter_method=top_bar">Gallery</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2022/07/01/README/">About</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
  </aside>
  
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>



<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/copybtn.js"></script>






<script src="/js/ocean.js"></script>

</body>

</html>